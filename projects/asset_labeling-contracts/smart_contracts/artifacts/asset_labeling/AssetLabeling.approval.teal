#pragma version 10
#pragma typetrack false

// smart_contracts.asset_labeling.contract.AssetLabeling.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 2 8 4294967295 4294967296
    bytecblock 0x151f7c75 0x0000 "ERR:NOEXIST" "" "admin" "ERR:EXISTS" 0x0002 "ERR:UNAUTH" 0x0000000000000000 "ERR:NOEMPTY" 0x0001 0x0005
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:59
    // self.admin = Txn.sender
    bytec 4 // "admin"
    txn Sender
    app_global_put

main_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@34
    pushbytess 0x8f0d7d8e 0x7c1b32f6 0x17e691ae 0x33d0ffdc 0x725616e7 0xfac1cf1b 0xb4c50b9f 0xa2dd2247 0xa37dea11 0x135ab21e 0x68f18efa 0xc2ed743f 0xa67f03c2 0xaaee0c61 0xb6c39f68 0x635be362 0x7093b10d 0x70ac99ad 0xd9a2bd9c 0x76c6528e 0x51f77bff 0xe1bb95fc 0x5540b80a 0x8a412f93 0x6f17cdd5 0x7a4ce4b9 0x366c51af 0xd5d3bad3 0x03ba98db // method "change_admin(account)void", method "add_label(string,string)void", method "remove_label(string)void", method "get_label(string)(string,uint64,uint64)", method "log_labels(string[])void", method "add_operator_to_label(account,string)void", method "remove_operator_from_label(account,string)void", method "get_operator_labels(account)string[]", method "add_label_to_asset(string,asset)void", method "add_label_to_assets(string,uint64[])void", method "remove_label_from_asset(string,asset)void", method "get_asset_labels(asset)string[]", method "get_assets_labels(uint64[])string[][]", method "get_asset_micro(uint64)(string,uint8)", method "get_assets_micro(uint64[])void", method "get_asset_micro_labels(uint64)(string,uint8,string[])", method "get_assets_micro_labels(uint64[])void", method "get_asset_tiny(uint64)(string,string,uint8)", method "get_assets_tiny(uint64[])void", method "get_asset_tiny_labels(uint64)(string,string,uint8,string[])", method "get_assets_tiny_labels(uint64[])void", method "get_asset_text(uint64)(string,string,string,string[])", method "get_assets_text(uint64[])void", method "get_asset_text_labels(uint64)(string,string,string)", method "get_assets_text_labels(uint64[])void", method "get_asset_small(uint64)(string,string,uint8,uint64,bool,bool,string[])", method "get_assets_small(uint64[])void", method "get_asset_full(uint64)(string,string,string,uint64,uint8,address,address,address,address,byte[],uint64,string[])", method "get_assets_full(uint64[])void"
    txna ApplicationArgs 0
    match main_change_admin_route@5 main_add_label_route@6 main_remove_label_route@7 main_get_label_route@8 main_log_labels_route@9 main_add_operator_to_label_route@10 main_remove_operator_from_label_route@11 main_get_operator_labels_route@12 main_add_label_to_asset_route@13 main_add_label_to_assets_route@14 main_remove_label_from_asset_route@15 main_get_asset_labels_route@16 main_get_assets_labels_route@17 main_get_asset_micro_route@18 main_get_assets_micro_route@19 main_get_asset_micro_labels_route@20 main_get_assets_micro_labels_route@21 main_get_asset_tiny_route@22 main_get_assets_tiny_route@23 main_get_asset_tiny_labels_route@24 main_get_assets_tiny_labels_route@25 main_get_asset_text_route@26 main_get_assets_text_route@27 main_get_asset_text_labels_route@28 main_get_assets_text_labels_route@29 main_get_asset_small_route@30 main_get_assets_small_route@31 main_get_asset_full_route@32 main_get_assets_full_route@33

main_after_if_else@38:
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    intc_1 // 0
    return

main_get_assets_full_route@33:
    // smart_contracts/asset_labeling/contract.py:493
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:493
    // @abimethod(readonly=True)
    callsub get_assets_full
    intc_0 // 1
    return

main_get_asset_full_route@32:
    // smart_contracts/asset_labeling/contract.py:489
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:489
    // @abimethod(readonly=True)
    callsub get_asset_full
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_small_route@31:
    // smart_contracts/asset_labeling/contract.py:458
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:458
    // @abimethod(readonly=True)
    callsub get_assets_small
    intc_0 // 1
    return

main_get_asset_small_route@30:
    // smart_contracts/asset_labeling/contract.py:454
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:454
    // @abimethod(readonly=True)
    callsub get_asset_small
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_text_labels_route@29:
    // smart_contracts/asset_labeling/contract.py:434
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:434
    // @abimethod(readonly=True)
    callsub get_assets_text_labels
    intc_0 // 1
    return

main_get_asset_text_labels_route@28:
    // smart_contracts/asset_labeling/contract.py:430
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:430
    // @abimethod(readonly=True)
    callsub get_asset_text_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_text_route@27:
    // smart_contracts/asset_labeling/contract.py:414
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:414
    // @abimethod(readonly=True)
    callsub get_assets_text
    intc_0 // 1
    return

main_get_asset_text_route@26:
    // smart_contracts/asset_labeling/contract.py:410
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:410
    // @abimethod(readonly=True)
    callsub get_asset_text
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_tiny_labels_route@25:
    // smart_contracts/asset_labeling/contract.py:393
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:393
    // @abimethod(readonly=True)
    callsub get_assets_tiny_labels
    intc_0 // 1
    return

main_get_asset_tiny_labels_route@24:
    // smart_contracts/asset_labeling/contract.py:389
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:389
    // @abimethod(readonly=True)
    callsub get_asset_tiny_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_tiny_route@23:
    // smart_contracts/asset_labeling/contract.py:372
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:372
    // @abimethod(readonly=True)
    callsub get_assets_tiny
    intc_0 // 1
    return

main_get_asset_tiny_route@22:
    // smart_contracts/asset_labeling/contract.py:368
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:368
    // @abimethod(readonly=True)
    callsub get_asset_tiny
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_micro_labels_route@21:
    // smart_contracts/asset_labeling/contract.py:352
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:352
    // @abimethod(readonly=True)
    callsub get_assets_micro_labels
    intc_0 // 1
    return

main_get_asset_micro_labels_route@20:
    // smart_contracts/asset_labeling/contract.py:348
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:348
    // @abimethod(readonly=True)
    callsub get_asset_micro_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_micro_route@19:
    // smart_contracts/asset_labeling/contract.py:332
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:332
    // @abimethod(readonly=True)
    callsub get_assets_micro
    intc_0 // 1
    return

main_get_asset_micro_route@18:
    // smart_contracts/asset_labeling/contract.py:328
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:328
    // @abimethod(readonly=True)
    callsub get_asset_micro
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_labels_route@17:
    // smart_contracts/asset_labeling/contract.py:301
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:301
    // @abimethod(readonly=True)
    callsub get_assets_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_asset_labels_route@16:
    // smart_contracts/asset_labeling/contract.py:294
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/asset_labeling/contract.py:294
    // @abimethod(readonly=True)
    callsub get_asset_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_remove_label_from_asset_route@15:
    // smart_contracts/asset_labeling/contract.py:260
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/asset_labeling/contract.py:260
    // @abimethod()
    callsub remove_label_from_asset
    intc_0 // 1
    return

main_add_label_to_assets_route@14:
    // smart_contracts/asset_labeling/contract.py:252
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/asset_labeling/contract.py:252
    // @abimethod()
    callsub add_label_to_assets
    intc_0 // 1
    return

main_add_label_to_asset_route@13:
    // smart_contracts/asset_labeling/contract.py:247
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/asset_labeling/contract.py:247
    // @abimethod()
    callsub add_label_to_asset
    intc_0 // 1
    return

main_get_operator_labels_route@12:
    // smart_contracts/asset_labeling/contract.py:207
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/asset_labeling/contract.py:207
    // @abimethod(readonly=True)
    callsub get_operator_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_remove_operator_from_label_route@11:
    // smart_contracts/asset_labeling/contract.py:166
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:166
    // @abimethod()
    callsub remove_operator_from_label
    intc_0 // 1
    return

main_add_operator_to_label_route@10:
    // smart_contracts/asset_labeling/contract.py:138
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:138
    // @abimethod()
    callsub add_operator_to_label
    intc_0 // 1
    return

main_log_labels_route@9:
    // smart_contracts/asset_labeling/contract.py:105
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:105
    // @abimethod(readonly=True)
    callsub log_labels
    intc_0 // 1
    return

main_get_label_route@8:
    // smart_contracts/asset_labeling/contract.py:100
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:100
    // @abimethod(readonly=True)
    callsub get_label
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_remove_label_route@7:
    // smart_contracts/asset_labeling/contract.py:93
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:93
    // @abimethod()
    callsub remove_label
    intc_0 // 1
    return

main_add_label_route@6:
    // smart_contracts/asset_labeling/contract.py:82
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:82
    // @abimethod()
    callsub add_label
    intc_0 // 1
    return

main_change_admin_route@5:
    // smart_contracts/asset_labeling/contract.py:77
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/asset_labeling/contract.py:77
    // @abimethod()
    callsub change_admin
    intc_0 // 1
    return

main_bare_routing@34:
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txn OnCompletion
    switch main___algopy_default_create@37 main_after_if_else@38 main_after_if_else@38 main_after_if_else@38 main_update@35 main_delete@36
    b main_after_if_else@38

main_delete@36:
    // smart_contracts/asset_labeling/contract.py:69
    // @arc4.baremethod(allow_actions=("DeleteApplication",))
    txn ApplicationID
    assert // can only call when not creating
    callsub delete
    intc_0 // 1
    return

main_update@35:
    // smart_contracts/asset_labeling/contract.py:65
    // @arc4.baremethod(allow_actions=("UpdateApplication",))
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main___algopy_default_create@37:
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_1 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_1 // 0
    swap

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 3
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@5
    frame_dig 4
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 3
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 4
    intc_2 // 2
    +
    frame_bury 3
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@5:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_dynamic_element(array_items_count: uint64, array_head_and_tail: bytes, new_items_count: uint64, new_head_and_tail: bytes) -> bytes:
dynamic_array_concat_dynamic_element:
    proto 4 1
    bytec_3 // ""
    dup
    frame_dig -2
    intc_2 // 2
    *
    frame_dig -4
    intc_2 // 2
    *
    intc_1 // 0

dynamic_array_concat_dynamic_element_for_header@1:
    frame_dig 4
    frame_dig 3
    <
    bz dynamic_array_concat_dynamic_element_after_for@4
    frame_dig -3
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@1

dynamic_array_concat_dynamic_element_after_for@4:
    frame_dig -3
    len
    frame_bury 0
    intc_1 // 0
    frame_bury 4

dynamic_array_concat_dynamic_element_for_header@5:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_dynamic_element_after_for@8
    frame_dig -1
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 0
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@5

dynamic_array_concat_dynamic_element_after_for@8:
    frame_dig -4
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig 1
    concat
    frame_dig -3
    frame_dig 3
    frame_dig 0
    substring3
    concat
    frame_dig -1
    len
    frame_dig -1
    frame_dig 2
    uncover 2
    substring3
    concat
    frame_bury 0
    retsub


// smart_contracts.asset_labeling.contract.b2str(b: bytes) -> bytes:
b2str:
    // smart_contracts/asset_labeling/contract.py:52-53
    // @subroutine
    // def b2str(b: Bytes) -> arc4.String:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:54
    // return arc4.String(String.from_bytes(b))
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.update() -> void:
update:
    // smart_contracts/asset_labeling/contract.py:67
    // self.admin_only()
    callsub admin_only
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.delete() -> void:
delete:
    // smart_contracts/asset_labeling/contract.py:71
    // self.admin_only()
    callsub admin_only
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.admin_only() -> void:
admin_only:
    // smart_contracts/asset_labeling/contract.py:75
    // ensure(Txn.sender == self.admin, S("ERR:UNAUTH"))
    txn Sender
    intc_1 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz admin_only_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:75
    // ensure(Txn.sender == self.admin, S("ERR:UNAUTH"))
    bytec 7 // "ERR:UNAUTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

admin_only_after_if_else@3:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.change_admin(new_admin: bytes) -> void:
change_admin:
    // smart_contracts/asset_labeling/contract.py:77-78
    // @abimethod()
    // def change_admin(self, new_admin: Account) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:79
    // self.admin_only()
    callsub admin_only
    // smart_contracts/asset_labeling/contract.py:80
    // self.admin = new_admin
    bytec 4 // "admin"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.add_label(id: bytes, name: bytes) -> void:
add_label:
    // smart_contracts/asset_labeling/contract.py:82-83
    // @abimethod()
    // def add_label(self, id: String, name: String) -> None:
    proto 2 0
    // smart_contracts/asset_labeling/contract.py:84
    // self.admin_only()
    callsub admin_only
    // smart_contracts/asset_labeling/contract.py:85
    // ensure(id not in self.labels, S("ERR:EXISTS"))
    frame_dig -2
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bz add_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:85
    // ensure(id not in self.labels, S("ERR:EXISTS"))
    bytec 5 // "ERR:EXISTS"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:86
    // ensure(id.bytes.length == 2, S("ERR:LENGTH"))
    frame_dig -2
    len
    intc_2 // 2
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz add_label_after_if_else@7
    // smart_contracts/asset_labeling/contract.py:86
    // ensure(id.bytes.length == 2, S("ERR:LENGTH"))
    pushbytes "ERR:LENGTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_label_after_if_else@7:
    // smart_contracts/asset_labeling/contract.py:88
    // arc4.String(name),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/asset_labeling/contract.py:87-91
    // self.labels[id] = LabelDescriptor(
    //     arc4.String(name),
    //     arc4.UInt64(0),
    //     arc4.UInt64(0),
    // )
    pushbytes 0x001200000000000000000000000000000000
    swap
    concat
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.remove_label(id: bytes) -> void:
remove_label:
    // smart_contracts/asset_labeling/contract.py:93-94
    // @abimethod()
    // def remove_label(self, id: String) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:95
    // self.admin_only()
    callsub admin_only
    // smart_contracts/asset_labeling/contract.py:96
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:96
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:97
    // ensure(self.labels[id].num_assets == 0, S("ERR:NOEMPTY"))
    frame_dig -1
    box_get
    assert // check self.labels entry exists
    extract 2 8 // on error: Index access is out of bounds
    bytec 8 // 0x0000000000000000
    b==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_label_after_if_else@7
    // smart_contracts/asset_labeling/contract.py:97
    // ensure(self.labels[id].num_assets == 0, S("ERR:NOEMPTY"))
    bytec 9 // "ERR:NOEMPTY"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_after_if_else@7:
    // smart_contracts/asset_labeling/contract.py:98
    // del self.labels[id]
    frame_dig -1
    box_del
    pop
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_label(id: bytes) -> bytes:
get_label:
    // smart_contracts/asset_labeling/contract.py:100-101
    // @abimethod(readonly=True)
    // def get_label(self, id: String) -> LabelDescriptor:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:102
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz get_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:102
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

get_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:103
    // return self.labels[id]
    frame_dig -1
    box_get
    assert // check self.labels entry exists
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.log_labels(ids: bytes) -> void:
log_labels:
    // smart_contracts/asset_labeling/contract.py:105-106
    // @abimethod(readonly=True)
    // def log_labels(self, ids: arc4.DynamicArray[arc4.String]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:107
    // for _idx, label_id in uenumerate(ids):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

log_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:107
    // for _idx, label_id in uenumerate(ids):
    frame_dig 1
    frame_dig 0
    <
    bz log_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    // smart_contracts/asset_labeling/contract.py:108
    // log(self.labels[label_id.native])
    extract 2 0
    box_get
    assert // check self.labels entry exists
    log
    intc_0 // 1
    +
    frame_bury 1
    b log_labels_for_header@1

log_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.admin_or_operator_only(label: bytes) -> void:
admin_or_operator_only:
    // smart_contracts/asset_labeling/contract.py:114-115
    // @subroutine
    // def admin_or_operator_only(self, label: String) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:116
    // if Txn.sender == self.admin:
    txn Sender
    intc_1 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    bz admin_or_operator_only_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:117
    // return
    retsub

admin_or_operator_only_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:118
    // self.operator_only(label)
    frame_dig -1
    callsub operator_only
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.operator_only(label: bytes) -> void:
operator_only:
    // smart_contracts/asset_labeling/contract.py:120-121
    // @subroutine
    // def operator_only(self, label: String) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:122
    // operator_index = self.get_operator_label_index(Txn.sender, label)
    txn Sender
    frame_dig -1
    callsub get_operator_label_index
    dup
    // smart_contracts/asset_labeling/contract.py:124
    // operator_index != UInt64(NOT_FOUND_KEY)
    intc 5 // 4294967296
    !=
    // smart_contracts/asset_labeling/contract.py:124-125
    // operator_index != UInt64(NOT_FOUND_KEY)
    // and operator_index != UInt64(NOT_FOUND_VALUE),
    bz operator_only_bool_false@3
    // smart_contracts/asset_labeling/contract.py:125
    // and operator_index != UInt64(NOT_FOUND_VALUE),
    frame_dig 0
    intc 4 // 4294967295
    !=
    // smart_contracts/asset_labeling/contract.py:124-125
    // operator_index != UInt64(NOT_FOUND_KEY)
    // and operator_index != UInt64(NOT_FOUND_VALUE),
    bz operator_only_bool_false@3
    intc_0 // 1

operator_only_bool_merge@4:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz operator_only_after_if_else@7
    // smart_contracts/asset_labeling/contract.py:126
    // S("ERR:UNAUTH"),
    bytec 7 // "ERR:UNAUTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

operator_only_after_if_else@7:
    retsub

operator_only_bool_false@3:
    intc_1 // 0
    b operator_only_bool_merge@4


// smart_contracts.asset_labeling.contract.AssetLabeling.get_operator_label_index(operator: bytes, label: bytes) -> uint64:
get_operator_label_index:
    // smart_contracts/asset_labeling/contract.py:129-130
    // @subroutine
    // def get_operator_label_index(self, operator: Account, label: String) -> UInt64:
    proto 2 1
    intc_1 // 0
    bytec_3 // ""
    dup
    // smart_contracts/asset_labeling/contract.py:131
    // if operator not in self.operators:
    frame_dig -2
    box_len
    bury 1
    bnz get_operator_label_index_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:132
    // return UInt64(NOT_FOUND_KEY)
    intc 5 // 4294967296
    frame_bury 0
    retsub

get_operator_label_index_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:133
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig -2
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.operators entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 1
    intc_1 // 0
    frame_bury 2

get_operator_label_index_for_header@3:
    // smart_contracts/asset_labeling/contract.py:133
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig 2
    frame_dig 1
    <
    bz get_operator_label_index_after_for@8
    frame_dig 0
    extract 2 0
    frame_dig 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    // smart_contracts/asset_labeling/contract.py:134
    // if stored_label == label:
    extract 2 0
    frame_dig -1
    ==
    bz get_operator_label_index_after_if_else@6
    // smart_contracts/asset_labeling/contract.py:135
    // return idx
    frame_dig 2
    frame_bury 0
    retsub

get_operator_label_index_after_if_else@6:
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b get_operator_label_index_for_header@3

get_operator_label_index_after_for@8:
    // smart_contracts/asset_labeling/contract.py:136
    // return UInt64(NOT_FOUND_VALUE)
    intc 4 // 4294967295
    frame_bury 0
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.add_operator_to_label(operator: bytes, label: bytes) -> void:
add_operator_to_label:
    // smart_contracts/asset_labeling/contract.py:138-139
    // @abimethod()
    // def add_operator_to_label(self, operator: Account, label: String) -> None:
    proto 2 0
    // smart_contracts/asset_labeling/contract.py:140
    // self.admin_or_operator_only(label)
    frame_dig -1
    callsub admin_or_operator_only
    // smart_contracts/asset_labeling/contract.py:141
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz add_operator_to_label_after_if_else@10
    // smart_contracts/asset_labeling/contract.py:141
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_operator_to_label_after_if_else@10:
    // smart_contracts/asset_labeling/contract.py:142-143
    // # check if operator exists already
    // if operator in self.operators:
    frame_dig -2
    box_len
    bury 1
    bz add_operator_to_label_else_body@2
    // smart_contracts/asset_labeling/contract.py:146
    // self.get_operator_label_index(operator, label)
    frame_dig -2
    frame_dig -1
    callsub get_operator_label_index
    // smart_contracts/asset_labeling/contract.py:147
    // == UInt64(NOT_FOUND_VALUE),
    intc 4 // 4294967295
    // smart_contracts/asset_labeling/contract.py:146-147
    // self.get_operator_label_index(operator, label)
    // == UInt64(NOT_FOUND_VALUE),
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz add_operator_to_label_after_if_else@6
    // smart_contracts/asset_labeling/contract.py:148
    // S("ERR:EXISTS"),
    bytec 5 // "ERR:EXISTS"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_operator_to_label_after_if_else@6:
    // smart_contracts/asset_labeling/contract.py:151-152
    // # add label to operator
    // existing = self.operators[operator].copy()
    frame_dig -2
    box_get
    assert // check self.operators entry exists
    // smart_contracts/asset_labeling/contract.py:153
    // existing.append(arc4.String(label))
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    // smart_contracts/asset_labeling/contract.py:154
    // self.operators[operator] = existing.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put

add_operator_to_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:159-160
    // # increment label operators
    // label_descriptor = self.labels[label].copy()
    frame_dig -1
    box_get
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:162
    // label_descriptor.num_operators.native + UInt64(1)
    dup
    pushint 10 // 10
    extract_uint64
    intc_0 // 1
    +
    // smart_contracts/asset_labeling/contract.py:161-163
    // label_descriptor.num_operators = arc4.UInt64(
    //     label_descriptor.num_operators.native + UInt64(1)
    // )
    itob
    replace2 10
    // smart_contracts/asset_labeling/contract.py:164
    // self.labels[label] = label_descriptor.copy()
    frame_dig -1
    box_del
    pop
    frame_dig -1
    swap
    box_put
    retsub

add_operator_to_label_else_body@2:
    // smart_contracts/asset_labeling/contract.py:156-157
    // # new operator, create new box
    // self.operators[operator] = arc4.DynamicArray(arc4.String(label))
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    bytec 6 // 0x0002
    swap
    concat
    bytec 10 // 0x0001
    swap
    concat
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    b add_operator_to_label_after_if_else@3


// smart_contracts.asset_labeling.contract.AssetLabeling.remove_operator_from_label(operator: bytes, label: bytes) -> void:
remove_operator_from_label:
    // smart_contracts/asset_labeling/contract.py:166-167
    // @abimethod()
    // def remove_operator_from_label(self, operator: Account, label: String) -> None:
    proto 2 0
    intc_1 // 0
    dupn 4
    bytec_3 // ""
    dupn 2
    // smart_contracts/asset_labeling/contract.py:168
    // self.admin_or_operator_only(label)
    frame_dig -1
    callsub admin_or_operator_only
    // smart_contracts/asset_labeling/contract.py:170
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@28
    // smart_contracts/asset_labeling/contract.py:170
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@28:
    // smart_contracts/asset_labeling/contract.py:171
    // ensure(operator in self.operators, S("ERR:NOEXIST"))
    frame_dig -2
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@32
    // smart_contracts/asset_labeling/contract.py:171
    // ensure(operator in self.operators, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@32:
    // smart_contracts/asset_labeling/contract.py:173-174
    // # ensure label exists in operator
    // label_idx = self.get_operator_label_index(operator, label)
    frame_dig -2
    frame_dig -1
    callsub get_operator_label_index
    dup
    frame_bury 7
    // smart_contracts/asset_labeling/contract.py:176
    // label_idx != UInt64(NOT_FOUND_VALUE)
    intc 4 // 4294967295
    !=
    // smart_contracts/asset_labeling/contract.py:176-178
    // label_idx != UInt64(NOT_FOUND_VALUE)
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    bz remove_operator_from_label_bool_false@3
    // smart_contracts/asset_labeling/contract.py:177-178
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    frame_dig 7
    // smart_contracts/asset_labeling/contract.py:178
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    intc 5 // 4294967296
    // smart_contracts/asset_labeling/contract.py:177-178
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    !=
    // smart_contracts/asset_labeling/contract.py:176-178
    // label_idx != UInt64(NOT_FOUND_VALUE)
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    bz remove_operator_from_label_bool_false@3
    intc_0 // 1

remove_operator_from_label_bool_merge@4:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@24
    // smart_contracts/asset_labeling/contract.py:179
    // S("ERR:NOEXIST"),
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@24:
    // smart_contracts/asset_labeling/contract.py:182-183
    // # ensure only empty labels can be left operator-less
    // label_descriptor = self.labels[label].copy()
    frame_dig -1
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:185
    // label_descriptor.num_operators > 1 or label_descriptor.num_assets == 0,
    extract 10 8 // on error: Index access is out of bounds
    pushbytes 0x0000000000000001
    b>
    bnz remove_operator_from_label_bool_true@6
    frame_dig 0
    extract 2 8 // on error: Index access is out of bounds
    bytec 8 // 0x0000000000000000
    b==
    bz remove_operator_from_label_bool_false@7

remove_operator_from_label_bool_true@6:
    intc_0 // 1

remove_operator_from_label_bool_merge@8:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@20
    // smart_contracts/asset_labeling/contract.py:186
    // S("ERR:NOEMPTY"),
    bytec 9 // "ERR:NOEMPTY"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@20:
    // smart_contracts/asset_labeling/contract.py:190
    // label_descriptor.num_operators.native - UInt64(1)
    frame_dig 0
    dup
    pushint 10 // 10
    extract_uint64
    intc_0 // 1
    -
    // smart_contracts/asset_labeling/contract.py:188-191
    // # decr operator count
    // label_descriptor.num_operators = arc4.UInt64(
    //     label_descriptor.num_operators.native - UInt64(1)
    // )
    itob
    replace2 10
    // smart_contracts/asset_labeling/contract.py:192
    // self.labels[label] = label_descriptor.copy()
    frame_dig -1
    box_del
    pop
    frame_dig -1
    swap
    box_put
    // smart_contracts/asset_labeling/contract.py:194
    // if self.operators[operator].length == 1:
    frame_dig -2
    box_get
    assert // check self.operators entry exists
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    ==
    bz remove_operator_from_label_else_body@10
    // smart_contracts/asset_labeling/contract.py:195
    // del self.operators[operator]
    frame_dig -2
    box_del
    pop
    retsub

remove_operator_from_label_else_body@10:
    // smart_contracts/asset_labeling/contract.py:197
    // next_list = arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    frame_bury 2
    // smart_contracts/asset_labeling/contract.py:198-201
    // # walk, push everything except index
    // # this implementation walks twice (once in get_operator_label_index)
    // # could be more efficient
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig -2
    box_get
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.operators entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 5
    intc_1 // 0
    frame_bury 6

remove_operator_from_label_for_header@11:
    // smart_contracts/asset_labeling/contract.py:198-201
    // # walk, push everything except index
    // # this implementation walks twice (once in get_operator_label_index)
    // # could be more efficient
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig 6
    frame_dig 5
    <
    bz remove_operator_from_label_after_for@16
    frame_dig 1
    extract 2 0
    frame_dig 6
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    frame_bury 4
    // smart_contracts/asset_labeling/contract.py:202
    // if label_idx != idx:
    frame_dig 7
    !=
    frame_dig 2
    frame_bury 3
    bz remove_operator_from_label_after_if_else@14
    // smart_contracts/asset_labeling/contract.py:203
    // next_list.append(stored_label)
    frame_dig 2
    frame_dig 4
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    frame_bury 3

remove_operator_from_label_after_if_else@14:
    frame_dig 3
    frame_bury 2
    frame_dig 6
    intc_0 // 1
    +
    frame_bury 6
    b remove_operator_from_label_for_header@11

remove_operator_from_label_after_for@16:
    // smart_contracts/asset_labeling/contract.py:205
    // self.operators[operator] = next_list.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    frame_dig 2
    box_put
    retsub

remove_operator_from_label_bool_false@7:
    intc_1 // 0
    b remove_operator_from_label_bool_merge@8

remove_operator_from_label_bool_false@3:
    intc_1 // 0
    b remove_operator_from_label_bool_merge@4


// smart_contracts.asset_labeling.contract.AssetLabeling.get_operator_labels(operator: bytes) -> bytes:
get_operator_labels:
    // smart_contracts/asset_labeling/contract.py:207-208
    // @abimethod(readonly=True)
    // def get_operator_labels(self, operator: Account) -> LabelList:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:209
    // if operator in self.operators:
    frame_dig -1
    box_len
    bury 1
    bz get_operator_labels_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:210
    // return self.operators[operator]
    frame_dig -1
    box_get
    assert // check self.operators entry exists
    retsub

get_operator_labels_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    // smart_contracts/asset_labeling/contract.py:211-212
    // # return empty list
    // return empty_list()
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._add_label_to_asset(label: bytes, asset: uint64) -> void:
_add_label_to_asset:
    // smart_contracts/asset_labeling/contract.py:223-224
    // @subroutine
    // def _add_label_to_asset(self, label: String, asset: Asset) -> None:
    proto 2 0
    intc_1 // 0
    dup
    bytec_3 // ""
    dup
    // smart_contracts/asset_labeling/contract.py:225
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -2
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz _add_label_to_asset_after_if_else@19
    // smart_contracts/asset_labeling/contract.py:225
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

_add_label_to_asset_after_if_else@19:
    // smart_contracts/asset_labeling/contract.py:226
    // if asset in self.assets:
    frame_dig -1
    itob
    dup
    frame_bury 1
    box_len
    bury 1
    bz _add_label_to_asset_else_body@2
    // smart_contracts/asset_labeling/contract.py:216
    // if asset not in self.assets:
    frame_dig 1
    box_len
    bury 1
    bnz _add_label_to_asset_after_if_else@6
    // smart_contracts/asset_labeling/contract.py:217
    // return UInt64(NOT_FOUND_KEY)
    intc 5 // 4294967296

_add_label_to_asset_after_inlined_smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_label_index@12:
    // smart_contracts/asset_labeling/contract.py:229
    // self.get_asset_label_index(asset, label) == UInt64(NOT_FOUND_VALUE),
    intc 4 // 4294967295
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz _add_label_to_asset_after_if_else@15
    // smart_contracts/asset_labeling/contract.py:230
    // S("ERR:EXISTS"),
    bytec 5 // "ERR:EXISTS"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

_add_label_to_asset_after_if_else@15:
    // smart_contracts/asset_labeling/contract.py:232-233
    // # add label to asset
    // existing = self.assets[asset].copy()
    frame_dig 1
    dup
    box_get
    assert // check self.assets entry exists
    // smart_contracts/asset_labeling/contract.py:234
    // existing.append(arc4.String(label))
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    // smart_contracts/asset_labeling/contract.py:235
    // self.assets[asset] = existing.copy()
    dig 1
    box_del
    pop
    box_put

_add_label_to_asset_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:240-241
    // # incr asset count
    // label_descriptor = self.labels[label].copy()
    frame_dig -2
    box_get
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:243
    // label_descriptor.num_assets.native + UInt64(1)
    dup
    intc_2 // 2
    extract_uint64
    intc_0 // 1
    +
    // smart_contracts/asset_labeling/contract.py:242-244
    // label_descriptor.num_assets = arc4.UInt64(
    //     label_descriptor.num_assets.native + UInt64(1)
    // )
    itob
    replace2 2
    // smart_contracts/asset_labeling/contract.py:245
    // self.labels[label] = label_descriptor.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    retsub

_add_label_to_asset_after_if_else@6:
    // smart_contracts/asset_labeling/contract.py:218
    // for idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 1
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.assets entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 2
    intc_1 // 0
    frame_bury 3

_add_label_to_asset_for_header@7:
    // smart_contracts/asset_labeling/contract.py:218
    // for idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 3
    frame_dig 2
    <
    bz _add_label_to_asset_after_for@11
    frame_dig 0
    extract 2 0
    frame_dig 3
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    // smart_contracts/asset_labeling/contract.py:219
    // if stored_label == label:
    extract 2 0
    frame_dig -2
    ==
    bz _add_label_to_asset_after_if_else@10
    frame_dig 3
    // smart_contracts/asset_labeling/contract.py:229
    // self.get_asset_label_index(asset, label) == UInt64(NOT_FOUND_VALUE),
    b _add_label_to_asset_after_inlined_smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_label_index@12

_add_label_to_asset_after_if_else@10:
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    b _add_label_to_asset_for_header@7

_add_label_to_asset_after_for@11:
    // smart_contracts/asset_labeling/contract.py:221
    // return UInt64(NOT_FOUND_VALUE)
    intc 4 // 4294967295
    // smart_contracts/asset_labeling/contract.py:229
    // self.get_asset_label_index(asset, label) == UInt64(NOT_FOUND_VALUE),
    b _add_label_to_asset_after_inlined_smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_label_index@12

_add_label_to_asset_else_body@2:
    // smart_contracts/asset_labeling/contract.py:237-238
    // # new asset, create new box
    // self.assets[asset] = arc4.DynamicArray(arc4.String(label))
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    bytec 6 // 0x0002
    swap
    concat
    bytec 10 // 0x0001
    swap
    concat
    frame_dig 1
    dup
    box_del
    pop
    swap
    box_put
    b _add_label_to_asset_after_if_else@3


// smart_contracts.asset_labeling.contract.AssetLabeling.add_label_to_asset(label: bytes, asset: uint64) -> void:
add_label_to_asset:
    // smart_contracts/asset_labeling/contract.py:247-248
    // @abimethod()
    // def add_label_to_asset(self, label: String, asset: Asset) -> None:
    proto 2 0
    // smart_contracts/asset_labeling/contract.py:249
    // self.operator_only(label)
    frame_dig -2
    callsub operator_only
    // smart_contracts/asset_labeling/contract.py:250
    // self._add_label_to_asset(label, asset)
    frame_dig -2
    frame_dig -1
    callsub _add_label_to_asset
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.add_label_to_assets(label: bytes, assets: bytes) -> void:
add_label_to_assets:
    // smart_contracts/asset_labeling/contract.py:252-255
    // @abimethod()
    // def add_label_to_assets(
    //     self, label: String, assets: arc4.DynamicArray[arc4.UInt64]
    // ) -> None:
    proto 2 0
    // smart_contracts/asset_labeling/contract.py:256
    // self.operator_only(label)
    frame_dig -2
    callsub operator_only
    // smart_contracts/asset_labeling/contract.py:257
    // for _i, asset in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

add_label_to_assets_for_header@1:
    // smart_contracts/asset_labeling/contract.py:257
    // for _i, asset in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz add_label_to_assets_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:258
    // self._add_label_to_asset(label, Asset(asset.native))
    extract_uint64
    frame_dig -2
    swap
    callsub _add_label_to_asset
    intc_0 // 1
    +
    frame_bury 1
    b add_label_to_assets_for_header@1

add_label_to_assets_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.remove_label_from_asset(label: bytes, asset: uint64) -> void:
remove_label_from_asset:
    // smart_contracts/asset_labeling/contract.py:260-261
    // @abimethod()
    // def remove_label_from_asset(self, label: String, asset: Asset) -> None:
    proto 2 0
    intc_1 // 0
    dupn 3
    bytec_3 // ""
    dupn 2
    // smart_contracts/asset_labeling/contract.py:262
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -2
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_label_from_asset_after_if_else@20
    // smart_contracts/asset_labeling/contract.py:262
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_from_asset_after_if_else@20:
    // smart_contracts/asset_labeling/contract.py:264
    // self.operator_only(label)
    frame_dig -2
    callsub operator_only
    // smart_contracts/asset_labeling/contract.py:266
    // found = False
    intc_1 // 0
    frame_bury 5
    // smart_contracts/asset_labeling/contract.py:267
    // if self.assets[asset].length == 1:
    frame_dig -1
    itob
    dup
    frame_bury 3
    box_get
    assert // check self.assets entry exists
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    ==
    bz remove_label_from_asset_else_body@5
    // smart_contracts/asset_labeling/contract.py:268
    // if self.assets[asset][0] == label:
    frame_dig 3
    box_get
    assert // check self.assets entry exists
    dup
    extract 2 0
    swap
    intc_1 // 0
    extract_uint16
    assert // Index access is out of bounds
    dup
    intc_1 // 0
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    frame_dig -2
    ==
    bz remove_label_from_asset_else_body@3
    // smart_contracts/asset_labeling/contract.py:269
    // del self.assets[asset]
    frame_dig 3
    box_del
    pop
    // smart_contracts/asset_labeling/contract.py:270
    // found = True
    intc_0 // 1
    frame_bury 5

remove_label_from_asset_after_if_else@13:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    frame_dig 5
    bnz remove_label_from_asset_after_if_else@16
    // smart_contracts/asset_labeling/contract.py:285
    // ensure(found, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_from_asset_after_if_else@16:
    // smart_contracts/asset_labeling/contract.py:287-288
    // # decr asset count
    // label_descriptor = self.labels[label].copy()
    frame_dig -2
    box_get
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:290
    // label_descriptor.num_assets.native - UInt64(1)
    dup
    intc_2 // 2
    extract_uint64
    intc_0 // 1
    -
    // smart_contracts/asset_labeling/contract.py:289-291
    // label_descriptor.num_assets = arc4.UInt64(
    //     label_descriptor.num_assets.native - UInt64(1)
    // )
    itob
    replace2 2
    // smart_contracts/asset_labeling/contract.py:292
    // self.labels[label] = label_descriptor.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    retsub

remove_label_from_asset_else_body@3:
    // smart_contracts/asset_labeling/contract.py:272
    // found = False
    intc_1 // 0
    frame_bury 5
    b remove_label_from_asset_after_if_else@13

remove_label_from_asset_else_body@5:
    // smart_contracts/asset_labeling/contract.py:274
    // next_list = arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    frame_bury 1
    // smart_contracts/asset_labeling/contract.py:275-277
    // # walk, push everything to new box except label
    // # save $found to throw if not found
    // for idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 3
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.assets entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 4
    intc_1 // 0
    frame_bury 6

remove_label_from_asset_for_header@6:
    // smart_contracts/asset_labeling/contract.py:275-277
    // # walk, push everything to new box except label
    // # save $found to throw if not found
    // for idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 6
    frame_dig 4
    <
    bz remove_label_from_asset_after_for@12
    frame_dig 0
    extract 2 0
    frame_dig 6
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    dup
    frame_bury 2
    // smart_contracts/asset_labeling/contract.py:278
    // if stored_label != label:
    extract 2 0
    frame_dig -2
    !=
    bz remove_label_from_asset_else_body@9
    // smart_contracts/asset_labeling/contract.py:279
    // next_list.append(stored_label)
    frame_dig 1
    frame_dig 2
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    frame_bury 1

remove_label_from_asset_after_if_else@10:
    frame_dig 6
    intc_0 // 1
    +
    frame_bury 6
    b remove_label_from_asset_for_header@6

remove_label_from_asset_else_body@9:
    // smart_contracts/asset_labeling/contract.py:281
    // found = True
    intc_0 // 1
    frame_bury 5
    b remove_label_from_asset_after_if_else@10

remove_label_from_asset_after_for@12:
    // smart_contracts/asset_labeling/contract.py:283
    // self.assets[asset] = next_list.copy()
    frame_dig 3
    dup
    box_del
    pop
    frame_dig 1
    box_put
    b remove_label_from_asset_after_if_else@13


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_labels(asset: uint64) -> bytes:
get_asset_labels:
    // smart_contracts/asset_labeling/contract.py:294-295
    // @abimethod(readonly=True)
    // def get_asset_labels(self, asset: Asset) -> LabelList:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:296
    // if asset in self.assets:
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz get_asset_labels_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:297
    // return self.assets[asset]
    frame_dig 0
    box_get
    assert // check self.assets entry exists
    swap
    retsub

get_asset_labels_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    // smart_contracts/asset_labeling/contract.py:298-299
    // # return empty
    // return empty_list()
    swap
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_labels(assets: bytes) -> bytes:
get_assets_labels:
    // smart_contracts/asset_labeling/contract.py:301-304
    // @abimethod(readonly=True)
    // def get_assets_labels(
    //     self, assets: arc4.DynamicArray[arc4.UInt64]
    // ) -> arc4.DynamicArray[LabelList]:
    proto 1 1
    intc_1 // 0
    // smart_contracts/asset_labeling/contract.py:305
    // out = arc4.DynamicArray[LabelList]()
    bytec_1 // 0x0000
    // smart_contracts/asset_labeling/contract.py:306
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:306
    // for _i, asset_id in uenumerate(assets):
    frame_dig 3
    frame_dig 2
    <
    bz get_assets_labels_after_for@7
    frame_dig -1
    extract 2 0
    frame_dig 3
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:307
    // asset = Asset(asset_id.native)
    extract_uint64
    // smart_contracts/asset_labeling/contract.py:308
    // if asset in self.assets:
    itob
    dup
    frame_bury 0
    box_len
    bury 1
    bz get_assets_labels_else_body@4
    // smart_contracts/asset_labeling/contract.py:309
    // out.append(self.assets[asset].copy())
    frame_dig 0
    box_get
    assert // check self.assets entry exists
    bytec 6 // 0x0002
    swap
    concat
    frame_dig 1
    dup
    intc_1 // 0
    extract_uint16
    swap
    extract 2 0
    intc_0 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    frame_bury 1

get_assets_labels_after_if_else@5:
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    b get_assets_labels_for_header@1

get_assets_labels_else_body@4:
    // smart_contracts/asset_labeling/contract.py:311
    // out.append(empty_list())
    frame_dig 1
    dup
    intc_1 // 0
    extract_uint16
    swap
    extract 2 0
    intc_0 // 1
    pushbytes 0x00020000
    callsub dynamic_array_concat_dynamic_element
    frame_bury 1
    b get_assets_labels_after_if_else@5

get_assets_labels_after_for@7:
    // smart_contracts/asset_labeling/contract.py:312
    // return out
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_micro(asset_id: uint64) -> bytes:
_get_asset_micro:
    // smart_contracts/asset_labeling/contract.py:320-321
    // @subroutine
    // def _get_asset_micro(self, asset_id: UInt64) -> AssetMicro:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:324
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:325
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:323-326
    // return AssetMicro(
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    // )
    pushbytes 0x0003
    swap
    concat
    swap
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_micro(asset: uint64) -> bytes:
get_asset_micro:
    // smart_contracts/asset_labeling/contract.py:328-329
    // @abimethod(readonly=True)
    // def get_asset_micro(self, asset: UInt64) -> AssetMicro:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:330
    // return self._get_asset_micro(asset)
    frame_dig -1
    callsub _get_asset_micro
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_micro(assets: bytes) -> void:
get_assets_micro:
    // smart_contracts/asset_labeling/contract.py:332-333
    // @abimethod(readonly=True)
    // def get_assets_micro(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:334
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_micro_for_header@1:
    // smart_contracts/asset_labeling/contract.py:334
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_micro_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:335
    // log(self._get_asset_micro(asset_id.native))
    extract_uint64
    callsub _get_asset_micro
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_micro_for_header@1

get_assets_micro_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_micro_labels(asset_id: uint64) -> bytes:
_get_asset_micro_labels:
    // smart_contracts/asset_labeling/contract.py:339-340
    // @subroutine
    // def _get_asset_micro_labels(self, asset_id: UInt64) -> AssetMicroLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:343
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:344
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:345
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_micro_labels_ternary_false@2
    frame_dig 2
    box_get
    assert // check self.assets entry exists

_get_asset_micro_labels_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:342-346
    // return AssetMicroLabels(
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    pushint 5 // 5
    +
    bytec 11 // 0x0005
    frame_dig 1
    concat
    swap
    itob
    extract 6 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_micro_labels_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_micro_labels_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_micro_labels(asset: uint64) -> bytes:
get_asset_micro_labels:
    // smart_contracts/asset_labeling/contract.py:348-349
    // @abimethod(readonly=True)
    // def get_asset_micro_labels(self, asset: UInt64) -> AssetMicroLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:350
    // return self._get_asset_micro_labels(asset)
    frame_dig -1
    callsub _get_asset_micro_labels
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_micro_labels(assets: bytes) -> void:
get_assets_micro_labels:
    // smart_contracts/asset_labeling/contract.py:352-353
    // @abimethod(readonly=True)
    // def get_assets_micro_labels(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:354
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_micro_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:354
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_micro_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:355
    // log(self._get_asset_micro_labels(asset_id.native))
    extract_uint64
    callsub _get_asset_micro_labels
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_micro_labels_for_header@1

get_assets_micro_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_tiny(asset_id: uint64) -> bytes:
_get_asset_tiny:
    // smart_contracts/asset_labeling/contract.py:359-360
    // @subroutine
    // def _get_asset_tiny(self, asset_id: UInt64) -> AssetTiny:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:363
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:364
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:365
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:362-366
    // return AssetTiny(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    // )
    dig 2
    len
    pushint 5 // 5
    +
    itob
    extract 6 2
    bytec 11 // 0x0005
    swap
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_tiny(asset: uint64) -> bytes:
get_asset_tiny:
    // smart_contracts/asset_labeling/contract.py:368-369
    // @abimethod(readonly=True)
    // def get_asset_tiny(self, asset: UInt64) -> AssetTiny:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:370
    // return self._get_asset_tiny(asset)
    frame_dig -1
    callsub _get_asset_tiny
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_tiny(assets: bytes) -> void:
get_assets_tiny:
    // smart_contracts/asset_labeling/contract.py:372-373
    // @abimethod(readonly=True)
    // def get_assets_tiny(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:374
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_tiny_for_header@1:
    // smart_contracts/asset_labeling/contract.py:374
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_tiny_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:375
    // log(self._get_asset_tiny(asset_id.native))
    extract_uint64
    callsub _get_asset_tiny
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_tiny_for_header@1

get_assets_tiny_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_tiny_labels(asset_id: uint64) -> bytes:
_get_asset_tiny_labels:
    // smart_contracts/asset_labeling/contract.py:379-380
    // @subroutine
    // def _get_asset_tiny_labels(self, asset_id: UInt64) -> AssetTinyLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:383
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:384
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:385
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:386
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_tiny_labels_ternary_false@2
    frame_dig 3
    box_get
    assert // check self.assets entry exists

_get_asset_tiny_labels_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:382-387
    // return AssetTinyLabels(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    pushint 7 // 7
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0007
    swap
    concat
    frame_dig 1
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 2
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_tiny_labels_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_tiny_labels_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_tiny_labels(asset: uint64) -> bytes:
get_asset_tiny_labels:
    // smart_contracts/asset_labeling/contract.py:389-390
    // @abimethod(readonly=True)
    // def get_asset_tiny_labels(self, asset: UInt64) -> AssetTinyLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:391
    // return self._get_asset_tiny_labels(asset)
    frame_dig -1
    callsub _get_asset_tiny_labels
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_tiny_labels(assets: bytes) -> void:
get_assets_tiny_labels:
    // smart_contracts/asset_labeling/contract.py:393-394
    // @abimethod(readonly=True)
    // def get_assets_tiny_labels(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:395
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_tiny_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:395
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_tiny_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:396
    // log(self._get_asset_tiny_labels(asset_id.native))
    extract_uint64
    callsub _get_asset_tiny_labels
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_tiny_labels_for_header@1

get_assets_tiny_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_text(asset_id: uint64) -> bytes:
_get_asset_text:
    // smart_contracts/asset_labeling/contract.py:400-401
    // @subroutine
    // def _get_asset_text(self, asset_id: UInt64) -> AssetText:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:404
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:405
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:406
    // url=b2str(asset.url),
    frame_dig -1
    asset_params_get AssetURL
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:407
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_text_ternary_false@2
    frame_dig 3
    box_get
    assert // check self.assets entry exists

_get_asset_text_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:403-408
    // return AssetText(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     url=b2str(asset.url),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    intc_3 // 8
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0008
    swap
    concat
    frame_dig 1
    dup
    cover 3
    len
    uncover 2
    +
    dup
    itob
    extract 6 2
    uncover 2
    swap
    concat
    frame_dig 2
    dup
    cover 3
    len
    uncover 2
    +
    itob
    extract 6 2
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_text_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_text_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_text(asset: uint64) -> bytes:
get_asset_text:
    // smart_contracts/asset_labeling/contract.py:410-411
    // @abimethod(readonly=True)
    // def get_asset_text(self, asset: UInt64) -> AssetText:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:412
    // return self._get_asset_text(asset)
    frame_dig -1
    callsub _get_asset_text
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_text(assets: bytes) -> void:
get_assets_text:
    // smart_contracts/asset_labeling/contract.py:414-415
    // @abimethod(readonly=True)
    // def get_assets_text(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:416
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_text_for_header@1:
    // smart_contracts/asset_labeling/contract.py:416
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_text_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:417
    // log(self._get_asset_text(asset_id.native))
    extract_uint64
    callsub _get_asset_text
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_text_for_header@1

get_assets_text_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_text_labels(asset_id: uint64) -> bytes:
_get_asset_text_labels:
    // smart_contracts/asset_labeling/contract.py:421-422
    // @subroutine
    // def _get_asset_text_labels(self, asset_id: UInt64) -> AssetTextLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:425
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:426
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:427
    // url=b2str(asset.url),
    frame_dig -1
    asset_params_get AssetURL
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:424-428
    // return AssetTextLabels(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     url=b2str(asset.url),
    // )
    dig 2
    len
    pushint 6 // 6
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0006
    swap
    concat
    dig 3
    len
    uncover 2
    +
    itob
    extract 6 2
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_text_labels(asset: uint64) -> bytes:
get_asset_text_labels:
    // smart_contracts/asset_labeling/contract.py:430-431
    // @abimethod(readonly=True)
    // def get_asset_text_labels(self, asset: UInt64) -> AssetTextLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:432
    // return self._get_asset_text_labels(asset)
    frame_dig -1
    callsub _get_asset_text_labels
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_text_labels(assets: bytes) -> void:
get_assets_text_labels:
    // smart_contracts/asset_labeling/contract.py:434-435
    // @abimethod(readonly=True)
    // def get_assets_text_labels(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:436
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_text_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:436
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_text_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:437
    // log(self._get_asset_text_labels(asset_id.native))
    extract_uint64
    callsub _get_asset_text_labels
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_text_labels_for_header@1

get_assets_text_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_small(asset_id: uint64) -> bytes:
_get_asset_small:
    // smart_contracts/asset_labeling/contract.py:441-442
    // @subroutine
    // def _get_asset_small(self, asset_id: UInt64) -> AssetSmall:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:445
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:446
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:447
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:448
    // total=arc4.UInt64(asset.total),
    frame_dig -1
    asset_params_get AssetTotal
    assert // asset exists
    itob
    // smart_contracts/asset_labeling/contract.py:449
    // has_freeze=arc4.Bool(asset.freeze != Global.zero_address),
    frame_dig -1
    asset_params_get AssetFreeze
    assert // asset exists
    global ZeroAddress
    !=
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/asset_labeling/contract.py:450
    // has_clawback=arc4.Bool(asset.clawback != Global.zero_address),
    frame_dig -1
    asset_params_get AssetClawback
    assert // asset exists
    global ZeroAddress
    !=
    pushbytes 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/asset_labeling/contract.py:451
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_small_ternary_false@2
    frame_dig 6
    box_get
    assert // check self.assets entry exists

_get_asset_small_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:444-452
    // return AssetSmall(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    //     total=arc4.UInt64(asset.total),
    //     has_freeze=arc4.Bool(asset.freeze != Global.zero_address),
    //     has_clawback=arc4.Bool(asset.clawback != Global.zero_address),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    pushint 16 // 16
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0010
    swap
    concat
    frame_dig 1
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 2
    concat
    frame_dig 3
    concat
    frame_dig 4
    concat
    frame_dig 5
    intc_1 // 0
    getbit
    pushint 105 // 105
    swap
    setbit
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_small_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_small_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_small(asset: uint64) -> bytes:
get_asset_small:
    // smart_contracts/asset_labeling/contract.py:454-455
    // @abimethod(readonly=True)
    // def get_asset_small(self, asset: UInt64) -> AssetSmall:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:456
    // return self._get_asset_small(asset)
    frame_dig -1
    callsub _get_asset_small
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_small(assets: bytes) -> void:
get_assets_small:
    // smart_contracts/asset_labeling/contract.py:458-459
    // @abimethod(readonly=True)
    // def get_assets_small(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:460
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_small_for_header@1:
    // smart_contracts/asset_labeling/contract.py:460
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_small_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:461
    // log(self._get_asset_small(asset_id.native))
    extract_uint64
    callsub _get_asset_small
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_small_for_header@1

get_assets_small_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_full(asset_id: uint64) -> bytes:
_get_asset_full:
    // smart_contracts/asset_labeling/contract.py:465-466
    // @subroutine
    // def _get_asset_full(self, asset_id: UInt64) -> AssetFull:
    proto 1 1
    intc_1 // 0
    dupn 11
    // smart_contracts/asset_labeling/contract.py:468
    // reserve_acct = Account(asset.reserve.bytes)
    frame_dig -1
    asset_params_get AssetReserve
    swap
    dup
    uncover 2
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:471
    // if reserve_acct.is_opted_in(asset)
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/asset_labeling/contract.py:470-472
    // asset.balance(reserve_acct)
    // if reserve_acct.is_opted_in(asset)
    // else UInt64(0)
    bz _get_asset_full_ternary_false@2
    // smart_contracts/asset_labeling/contract.py:470
    // asset.balance(reserve_acct)
    frame_dig 12
    frame_dig -1
    asset_holding_get AssetBalance
    assert // account opted into asset

_get_asset_full_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:475
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    frame_bury 1
    // smart_contracts/asset_labeling/contract.py:476
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    frame_bury 2
    // smart_contracts/asset_labeling/contract.py:477
    // url=b2str(asset.url),
    frame_dig -1
    asset_params_get AssetURL
    assert // asset exists
    callsub b2str
    frame_bury 3
    // smart_contracts/asset_labeling/contract.py:478
    // total=arc4.UInt64(asset.total),
    frame_dig -1
    asset_params_get AssetTotal
    assert // asset exists
    itob
    frame_bury 6
    // smart_contracts/asset_labeling/contract.py:479
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    frame_bury 5
    // smart_contracts/asset_labeling/contract.py:480
    // manager=arc4.Address(asset.manager),
    frame_dig -1
    asset_params_get AssetManager
    swap
    frame_bury 9
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:481
    // freeze=arc4.Address(asset.freeze),
    frame_dig -1
    asset_params_get AssetFreeze
    swap
    frame_bury 10
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:482
    // clawback=arc4.Address(asset.clawback),
    frame_dig -1
    asset_params_get AssetClawback
    swap
    frame_bury 11
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:483
    // reserve=arc4.Address(asset.reserve),
    frame_dig -1
    asset_params_get AssetReserve
    swap
    frame_bury 8
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:485
    // metadata_hash=arc4.DynamicBytes(asset.metadata_hash),
    frame_dig -1
    asset_params_get AssetMetadataHash
    assert // asset exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_bury 0
    // smart_contracts/asset_labeling/contract.py:484
    // reserve_balance=arc4.UInt64(reserve_balance),
    itob
    frame_bury 7
    // smart_contracts/asset_labeling/contract.py:486
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    frame_bury 4
    box_len
    bury 1
    bz _get_asset_full_ternary_false@5
    frame_dig 4
    box_get
    assert // check self.assets entry exists

_get_asset_full_ternary_merge@6:
    // smart_contracts/asset_labeling/contract.py:474-487
    // return AssetFull(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     url=b2str(asset.url),
    //     total=arc4.UInt64(asset.total),
    //     decimals=arc4.UInt8(asset.decimals),
    //     manager=arc4.Address(asset.manager),
    //     freeze=arc4.Address(asset.freeze),
    //     clawback=arc4.Address(asset.clawback),
    //     reserve=arc4.Address(asset.reserve),
    //     reserve_balance=arc4.UInt64(reserve_balance),
    //     metadata_hash=arc4.DynamicBytes(asset.metadata_hash),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 1
    dup
    len
    pushint 155 // 155
    +
    dup
    itob
    extract 6 2
    pushbytes 0x009b
    swap
    concat
    frame_dig 2
    dup
    cover 3
    len
    uncover 2
    +
    dup
    itob
    extract 6 2
    uncover 2
    swap
    concat
    frame_dig 3
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 6
    concat
    frame_dig 5
    concat
    frame_dig 9
    concat
    frame_dig 10
    concat
    frame_dig 11
    concat
    frame_dig 8
    concat
    dig 1
    itob
    extract 6 2
    concat
    frame_dig 0
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 7
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_full_ternary_false@5:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_full_ternary_merge@6

_get_asset_full_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:472
    // else UInt64(0)
    intc_1 // 0
    b _get_asset_full_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_full(asset: uint64) -> bytes:
get_asset_full:
    // smart_contracts/asset_labeling/contract.py:489-490
    // @abimethod(readonly=True)
    // def get_asset_full(self, asset: UInt64) -> AssetFull:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:491
    // return self._get_asset_full(asset)
    frame_dig -1
    callsub _get_asset_full
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_full(assets: bytes) -> void:
get_assets_full:
    // smart_contracts/asset_labeling/contract.py:493-494
    // @abimethod(readonly=True)
    // def get_assets_full(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:495
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_full_for_header@1:
    // smart_contracts/asset_labeling/contract.py:495
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_full_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:496
    // log(self._get_asset_full(asset_id.native))
    extract_uint64
    callsub _get_asset_full
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_full_for_header@1

get_assets_full_after_for@4:
    retsub
