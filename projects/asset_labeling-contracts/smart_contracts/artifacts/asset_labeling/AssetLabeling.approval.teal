#pragma version 10
#pragma typetrack false

// smart_contracts.asset_labeling.contract.AssetLabeling.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 2 8 4294967295 4294967296
    bytecblock 0x151f7c75 0x0000 "ERR:NOEXIST" "" 0x0000000000000000 "admin" "ERR:LENGTH" "ERR:EXISTS" "ERR:NOEMPTY" 0x0002 0x00 "ERR:UNAUTH" 0x0001 0x0005
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:59
    // self.admin = Txn.sender
    bytec 5 // "admin"
    txn Sender
    app_global_put

main_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@39
    pushbytess 0x8f0d7d8e 0x33a2e2f7 0xb72bb78f 0x976cde64 0x17e691ae 0x7665d2b4 0x725616e7 0xfac1cf1b 0x6fd8148c 0xb4c50b9f 0xa2dd2247 0xa37dea11 0x135ab21e 0x68f18efa 0x97f40a8a 0xc2ed743f 0xa67f03c2 0x97a32123 0xaaee0c61 0xb6c39f68 0x635be362 0x7093b10d 0x70ac99ad 0xd9a2bd9c 0x76c6528e 0x51f77bff 0x20d9f24c 0x5540b80a 0x0710e5c4 0x6f17cdd5 0x7a4ce4b9 0x366c51af 0x34a48fbc 0x03ba98db // method "change_admin(account)void", method "add_label(string,string,string)void", method "has_label(string)uint64", method "change_label(string,string,string)void", method "remove_label(string)void", method "get_label(string)(string,string,uint64,uint64)", method "log_labels(string[])void", method "add_operator_to_label(account,string)void", method "has_operator_label(account,string)uint64", method "remove_operator_from_label(account,string)void", method "get_operator_labels(account)string[]", method "add_label_to_asset(string,asset)void", method "add_label_to_assets(string,uint64[])void", method "remove_label_from_asset(string,asset)void", method "has_asset_label(uint64,string)uint64", method "get_asset_labels(asset)string[]", method "get_assets_labels(uint64[])string[][]", method "log_assets_labels(uint64[])void", method "get_asset_micro(uint64)(string,uint8)", method "get_assets_micro(uint64[])void", method "get_asset_micro_labels(uint64)(string,uint8,string[])", method "get_assets_micro_labels(uint64[])void", method "get_asset_tiny(uint64)(string,string,uint8)", method "get_assets_tiny(uint64[])void", method "get_asset_tiny_labels(uint64)(string,string,uint8,string[])", method "get_assets_tiny_labels(uint64[])void", method "get_asset_text(uint64)(string,string,string)", method "get_assets_text(uint64[])void", method "get_asset_text_labels(uint64)(string,string,string,string[])", method "get_assets_text_labels(uint64[])void", method "get_asset_small(uint64)(string,string,uint8,uint64,bool,bool,string[])", method "get_assets_small(uint64[])void", method "get_asset_full(uint64)(string,string,string,uint64,uint8,address,address,address,address,address,bool,byte[],uint64,string[])", method "get_assets_full(uint64[])void"
    txna ApplicationArgs 0
    match main_change_admin_route@5 main_add_label_route@6 main_has_label_route@7 main_change_label_route@8 main_remove_label_route@9 main_get_label_route@10 main_log_labels_route@11 main_add_operator_to_label_route@12 main_has_operator_label_route@13 main_remove_operator_from_label_route@14 main_get_operator_labels_route@15 main_add_label_to_asset_route@16 main_add_label_to_assets_route@17 main_remove_label_from_asset_route@18 main_has_asset_label_route@19 main_get_asset_labels_route@20 main_get_assets_labels_route@21 main_log_assets_labels_route@22 main_get_asset_micro_route@23 main_get_assets_micro_route@24 main_get_asset_micro_labels_route@25 main_get_assets_micro_labels_route@26 main_get_asset_tiny_route@27 main_get_assets_tiny_route@28 main_get_asset_tiny_labels_route@29 main_get_assets_tiny_labels_route@30 main_get_asset_text_route@31 main_get_assets_text_route@32 main_get_asset_text_labels_route@33 main_get_assets_text_labels_route@34 main_get_asset_small_route@35 main_get_assets_small_route@36 main_get_asset_full_route@37 main_get_assets_full_route@38

main_after_if_else@43:
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    intc_1 // 0
    return

main_get_assets_full_route@38:
    // smart_contracts/asset_labeling/contract.py:535
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:535
    // @abimethod(readonly=True)
    callsub get_assets_full
    intc_0 // 1
    return

main_get_asset_full_route@37:
    // smart_contracts/asset_labeling/contract.py:531
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:531
    // @abimethod(readonly=True)
    callsub get_asset_full
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_small_route@36:
    // smart_contracts/asset_labeling/contract.py:498
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:498
    // @abimethod(readonly=True)
    callsub get_assets_small
    intc_0 // 1
    return

main_get_asset_small_route@35:
    // smart_contracts/asset_labeling/contract.py:494
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:494
    // @abimethod(readonly=True)
    callsub get_asset_small
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_text_labels_route@34:
    // smart_contracts/asset_labeling/contract.py:474
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:474
    // @abimethod(readonly=True)
    callsub get_assets_text_labels
    intc_0 // 1
    return

main_get_asset_text_labels_route@33:
    // smart_contracts/asset_labeling/contract.py:470
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:470
    // @abimethod(readonly=True)
    callsub get_asset_text_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_text_route@32:
    // smart_contracts/asset_labeling/contract.py:453
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:453
    // @abimethod(readonly=True)
    callsub get_assets_text
    intc_0 // 1
    return

main_get_asset_text_route@31:
    // smart_contracts/asset_labeling/contract.py:449
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:449
    // @abimethod(readonly=True)
    callsub get_asset_text
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_tiny_labels_route@30:
    // smart_contracts/asset_labeling/contract.py:433
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:433
    // @abimethod(readonly=True)
    callsub get_assets_tiny_labels
    intc_0 // 1
    return

main_get_asset_tiny_labels_route@29:
    // smart_contracts/asset_labeling/contract.py:429
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:429
    // @abimethod(readonly=True)
    callsub get_asset_tiny_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_tiny_route@28:
    // smart_contracts/asset_labeling/contract.py:412
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:412
    // @abimethod(readonly=True)
    callsub get_assets_tiny
    intc_0 // 1
    return

main_get_asset_tiny_route@27:
    // smart_contracts/asset_labeling/contract.py:408
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:408
    // @abimethod(readonly=True)
    callsub get_asset_tiny
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_micro_labels_route@26:
    // smart_contracts/asset_labeling/contract.py:392
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:392
    // @abimethod(readonly=True)
    callsub get_assets_micro_labels
    intc_0 // 1
    return

main_get_asset_micro_labels_route@25:
    // smart_contracts/asset_labeling/contract.py:388
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:388
    // @abimethod(readonly=True)
    callsub get_asset_micro_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_assets_micro_route@24:
    // smart_contracts/asset_labeling/contract.py:372
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:372
    // @abimethod(readonly=True)
    callsub get_assets_micro
    intc_0 // 1
    return

main_get_asset_micro_route@23:
    // smart_contracts/asset_labeling/contract.py:368
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/asset_labeling/contract.py:368
    // @abimethod(readonly=True)
    callsub get_asset_micro
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_log_assets_labels_route@22:
    // smart_contracts/asset_labeling/contract.py:345
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:345
    // @abimethod(readonly=True)
    callsub log_assets_labels
    intc_0 // 1
    return

main_get_assets_labels_route@21:
    // smart_contracts/asset_labeling/contract.py:332
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:332
    // @abimethod(readonly=True)
    callsub get_assets_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_asset_labels_route@20:
    // smart_contracts/asset_labeling/contract.py:325
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/asset_labeling/contract.py:325
    // @abimethod(readonly=True)
    callsub get_asset_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_has_asset_label_route@19:
    // smart_contracts/asset_labeling/contract.py:317
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:317
    // @abimethod(readonly=True)
    callsub has_asset_label
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_remove_label_from_asset_route@18:
    // smart_contracts/asset_labeling/contract.py:283
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/asset_labeling/contract.py:283
    // @abimethod()
    callsub remove_label_from_asset
    intc_0 // 1
    return

main_add_label_to_assets_route@17:
    // smart_contracts/asset_labeling/contract.py:275
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/asset_labeling/contract.py:275
    // @abimethod()
    callsub add_label_to_assets
    intc_0 // 1
    return

main_add_label_to_asset_route@16:
    // smart_contracts/asset_labeling/contract.py:270
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/asset_labeling/contract.py:270
    // @abimethod()
    callsub add_label_to_asset
    intc_0 // 1
    return

main_get_operator_labels_route@15:
    // smart_contracts/asset_labeling/contract.py:229
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/asset_labeling/contract.py:229
    // @abimethod(readonly=True)
    callsub get_operator_labels
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_remove_operator_from_label_route@14:
    // smart_contracts/asset_labeling/contract.py:188
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:188
    // @abimethod()
    callsub remove_operator_from_label
    intc_0 // 1
    return

main_has_operator_label_route@13:
    // smart_contracts/asset_labeling/contract.py:182
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:182
    // @abimethod(readonly=True)
    callsub has_operator_label
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_add_operator_to_label_route@12:
    // smart_contracts/asset_labeling/contract.py:154
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:154
    // @abimethod()
    callsub add_operator_to_label
    intc_0 // 1
    return

main_log_labels_route@11:
    // smart_contracts/asset_labeling/contract.py:121
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/asset_labeling/contract.py:121
    // @abimethod(readonly=True)
    callsub log_labels
    intc_0 // 1
    return

main_get_label_route@10:
    // smart_contracts/asset_labeling/contract.py:116
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:116
    // @abimethod(readonly=True)
    callsub get_label
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_remove_label_route@9:
    // smart_contracts/asset_labeling/contract.py:108
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:108
    // @abimethod()
    callsub remove_label
    intc_0 // 1
    return

main_change_label_route@8:
    // smart_contracts/asset_labeling/contract.py:99
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:99
    // @abimethod()
    callsub change_label
    intc_0 // 1
    return

main_has_label_route@7:
    // smart_contracts/asset_labeling/contract.py:94
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:94
    // @abimethod(readonly=True)
    callsub has_label
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_add_label_route@6:
    // smart_contracts/asset_labeling/contract.py:82
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    // smart_contracts/asset_labeling/contract.py:82
    // @abimethod()
    callsub add_label
    intc_0 // 1
    return

main_change_admin_route@5:
    // smart_contracts/asset_labeling/contract.py:77
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/asset_labeling/contract.py:77
    // @abimethod()
    callsub change_admin
    intc_0 // 1
    return

main_bare_routing@39:
    // smart_contracts/asset_labeling/contract.py:57
    // class AssetLabeling(ARC4Contract):
    txn OnCompletion
    switch main___algopy_default_create@42 main_after_if_else@43 main_after_if_else@43 main_after_if_else@43 main_update@40 main_delete@41
    b main_after_if_else@43

main_delete@41:
    // smart_contracts/asset_labeling/contract.py:69
    // @arc4.baremethod(allow_actions=("DeleteApplication",))
    txn ApplicationID
    assert // can only call when not creating
    callsub delete
    intc_0 // 1
    return

main_update@40:
    // smart_contracts/asset_labeling/contract.py:65
    // @arc4.baremethod(allow_actions=("UpdateApplication",))
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main___algopy_default_create@42:
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// _puya_lib.arc4.dynamic_array_concat_byte_length_head(array: bytes, new_items_bytes: bytes, new_items_count: uint64) -> bytes:
dynamic_array_concat_byte_length_head:
    proto 3 1
    frame_dig -3
    intc_1 // 0
    extract_uint16
    dup
    frame_dig -1
    +
    swap
    intc_2 // 2
    *
    intc_2 // 2
    +
    dig 1
    itob
    extract 6 2
    cover 2
    frame_dig -3
    intc_2 // 2
    dig 2
    substring3
    frame_dig -1
    intc_2 // 2
    *
    bzero
    concat
    frame_dig -3
    len
    frame_dig -3
    uncover 3
    uncover 2
    substring3
    concat
    frame_dig -2
    concat
    swap
    intc_2 // 2
    *
    dup
    intc_1 // 0
    swap

dynamic_array_concat_byte_length_head_for_header@2:
    frame_dig 3
    frame_dig 2
    <
    bz dynamic_array_concat_byte_length_head_after_for@5
    frame_dig 4
    dup
    itob
    extract 6 2
    frame_dig 1
    frame_dig 3
    dup
    cover 4
    uncover 2
    replace3
    dup
    frame_bury 1
    dig 1
    extract_uint16
    intc_2 // 2
    +
    +
    frame_bury 4
    intc_2 // 2
    +
    frame_bury 3
    b dynamic_array_concat_byte_length_head_for_header@2

dynamic_array_concat_byte_length_head_after_for@5:
    frame_dig 0
    frame_dig 1
    concat
    frame_bury 0
    retsub


// _puya_lib.arc4.dynamic_array_concat_dynamic_element(array_items_count: uint64, array_head_and_tail: bytes, new_items_count: uint64, new_head_and_tail: bytes) -> bytes:
dynamic_array_concat_dynamic_element:
    proto 4 1
    bytec_3 // ""
    dup
    frame_dig -2
    intc_2 // 2
    *
    frame_dig -4
    intc_2 // 2
    *
    intc_1 // 0

dynamic_array_concat_dynamic_element_for_header@1:
    frame_dig 4
    frame_dig 3
    <
    bz dynamic_array_concat_dynamic_element_after_for@4
    frame_dig -3
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@1

dynamic_array_concat_dynamic_element_after_for@4:
    frame_dig -3
    len
    frame_bury 0
    intc_1 // 0
    frame_bury 4

dynamic_array_concat_dynamic_element_for_header@5:
    frame_dig 4
    frame_dig 2
    <
    bz dynamic_array_concat_dynamic_element_after_for@8
    frame_dig -1
    frame_dig 4
    dup
    cover 2
    extract_uint16
    frame_dig 0
    +
    itob
    extract 6 2
    frame_dig 1
    swap
    concat
    frame_bury 1
    intc_2 // 2
    +
    frame_bury 4
    b dynamic_array_concat_dynamic_element_for_header@5

dynamic_array_concat_dynamic_element_after_for@8:
    frame_dig -4
    frame_dig -2
    +
    itob
    extract 6 2
    frame_dig 1
    concat
    frame_dig -3
    frame_dig 3
    frame_dig 0
    substring3
    concat
    frame_dig -1
    len
    frame_dig -1
    frame_dig 2
    uncover 2
    substring3
    concat
    frame_bury 0
    retsub


// smart_contracts.asset_labeling.contract.b2str(b: bytes) -> bytes:
b2str:
    // smart_contracts/asset_labeling/contract.py:52-53
    // @subroutine
    // def b2str(b: Bytes) -> arc4.String:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:54
    // return arc4.String(String.from_bytes(b))
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.update() -> void:
update:
    // smart_contracts/asset_labeling/contract.py:67
    // self.admin_only()
    callsub admin_only
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.delete() -> void:
delete:
    // smart_contracts/asset_labeling/contract.py:71
    // self.admin_only()
    callsub admin_only
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.admin_only() -> void:
admin_only:
    // smart_contracts/asset_labeling/contract.py:75
    // ensure(Txn.sender == self.admin, S("ERR:UNAUTH"))
    txn Sender
    intc_1 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz admin_only_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:75
    // ensure(Txn.sender == self.admin, S("ERR:UNAUTH"))
    bytec 11 // "ERR:UNAUTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

admin_only_after_if_else@3:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.change_admin(new_admin: bytes) -> void:
change_admin:
    // smart_contracts/asset_labeling/contract.py:77-78
    // @abimethod()
    // def change_admin(self, new_admin: Account) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:79
    // self.admin_only()
    callsub admin_only
    // smart_contracts/asset_labeling/contract.py:80
    // self.admin = new_admin
    bytec 5 // "admin"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.add_label(id: bytes, name: bytes, url: bytes) -> void:
add_label:
    // smart_contracts/asset_labeling/contract.py:82-83
    // @abimethod()
    // def add_label(self, id: String, name: String, url: String) -> None:  # noqa A002
    proto 3 0
    // smart_contracts/asset_labeling/contract.py:84
    // self.admin_only()
    callsub admin_only
    // smart_contracts/asset_labeling/contract.py:85
    // ensure(id not in self.labels, S("ERR:EXISTS"))
    frame_dig -3
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bz add_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:85
    // ensure(id not in self.labels, S("ERR:EXISTS"))
    bytec 7 // "ERR:EXISTS"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:86
    // ensure(id.bytes.length == 2, S("ERR:LENGTH"))
    frame_dig -3
    len
    intc_2 // 2
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz add_label_after_if_else@7
    // smart_contracts/asset_labeling/contract.py:86
    // ensure(id.bytes.length == 2, S("ERR:LENGTH"))
    bytec 6 // "ERR:LENGTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_label_after_if_else@7:
    // smart_contracts/asset_labeling/contract.py:88
    // arc4.String(name),
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    // smart_contracts/asset_labeling/contract.py:89
    // arc4.String(url),
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // smart_contracts/asset_labeling/contract.py:87-92
    // self.labels[id] = LabelDescriptor(
    //     arc4.String(name),
    //     arc4.String(url),
    //     arc4.UInt64(0),
    //     arc4.UInt64(0),
    // )
    dig 1
    len
    pushint 20 // 20
    +
    itob
    extract 6 2
    pushbytes 0x0014
    swap
    concat
    // smart_contracts/asset_labeling/contract.py:90
    // arc4.UInt64(0),
    bytec 4 // 0x0000000000000000
    // smart_contracts/asset_labeling/contract.py:87-92
    // self.labels[id] = LabelDescriptor(
    //     arc4.String(name),
    //     arc4.String(url),
    //     arc4.UInt64(0),
    //     arc4.UInt64(0),
    // )
    concat
    // smart_contracts/asset_labeling/contract.py:91
    // arc4.UInt64(0),
    bytec 4 // 0x0000000000000000
    // smart_contracts/asset_labeling/contract.py:87-92
    // self.labels[id] = LabelDescriptor(
    //     arc4.String(name),
    //     arc4.String(url),
    //     arc4.UInt64(0),
    //     arc4.UInt64(0),
    // )
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig -3
    box_del
    pop
    frame_dig -3
    swap
    box_put
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.has_label(id: bytes) -> uint64:
has_label:
    // smart_contracts/asset_labeling/contract.py:94-95
    // @abimethod(readonly=True)
    // def has_label(self, id: String) -> UInt64:  # noqa A002
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:96
    // ensure(id.bytes.length == 2, S("ERR:LENGTH"))
    frame_dig -1
    len
    intc_2 // 2
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz has_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:96
    // ensure(id.bytes.length == 2, S("ERR:LENGTH"))
    bytec 6 // "ERR:LENGTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

has_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:97
    // return UInt64(id in self.labels)
    frame_dig -1
    box_len
    bury 1
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.change_label(id: bytes, name: bytes, url: bytes) -> void:
change_label:
    // smart_contracts/asset_labeling/contract.py:99-100
    // @abimethod()
    // def change_label(self, id: String, name: String, url: String) -> None:  # noqa A002
    proto 3 0
    // smart_contracts/asset_labeling/contract.py:101
    // self.admin_only()
    callsub admin_only
    // smart_contracts/asset_labeling/contract.py:102
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    frame_dig -3
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz change_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:102
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

change_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:103
    // label_descriptor = self.labels[id].copy()
    frame_dig -3
    box_get
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:104
    // label_descriptor.name = arc4.String(name)
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    dig 1
    intc_1 // 0
    extract_uint16
    dig 2
    intc_1 // 0
    dig 2
    extract3
    dig 3
    intc_2 // 2
    extract_uint16
    dig 4
    len
    uncover 5
    dig 2
    uncover 2
    substring3
    uncover 2
    dig 4
    concat
    swap
    concat
    swap
    uncover 2
    -
    uncover 2
    len
    dig 2
    intc_2 // 2
    extract_uint16
    +
    swap
    -
    itob
    extract 6 2
    replace2 2
    // smart_contracts/asset_labeling/contract.py:105
    // label_descriptor.url = arc4.String(url)
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    dig 1
    intc_2 // 2
    extract_uint16
    uncover 2
    intc_1 // 0
    uncover 2
    extract3
    swap
    concat
    // smart_contracts/asset_labeling/contract.py:106
    // self.labels[id] = label_descriptor.copy()
    frame_dig -3
    box_del
    pop
    frame_dig -3
    swap
    box_put
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.remove_label(id: bytes) -> void:
remove_label:
    // smart_contracts/asset_labeling/contract.py:108-109
    // @abimethod()
    // def remove_label(self, id: String) -> None:  # noqa A002
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:110
    // self.admin_only()
    callsub admin_only
    // smart_contracts/asset_labeling/contract.py:111
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:111
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:112
    // ensure(self.labels[id].num_operators == 0, S("ERR:NOEMPTY"))
    frame_dig -1
    box_get
    assert // check self.labels entry exists
    extract 12 8 // on error: Index access is out of bounds
    bytec 4 // 0x0000000000000000
    b==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_label_after_if_else@7
    // smart_contracts/asset_labeling/contract.py:112
    // ensure(self.labels[id].num_operators == 0, S("ERR:NOEMPTY"))
    bytec 8 // "ERR:NOEMPTY"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_after_if_else@7:
    // smart_contracts/asset_labeling/contract.py:113
    // ensure(self.labels[id].num_assets == 0, S("ERR:NOEMPTY"))
    frame_dig -1
    box_get
    assert // check self.labels entry exists
    extract 4 8 // on error: Index access is out of bounds
    bytec 4 // 0x0000000000000000
    b==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_label_after_if_else@11
    // smart_contracts/asset_labeling/contract.py:113
    // ensure(self.labels[id].num_assets == 0, S("ERR:NOEMPTY"))
    bytec 8 // "ERR:NOEMPTY"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_after_if_else@11:
    // smart_contracts/asset_labeling/contract.py:114
    // del self.labels[id]
    frame_dig -1
    box_del
    pop
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_label(id: bytes) -> bytes:
get_label:
    // smart_contracts/asset_labeling/contract.py:116-117
    // @abimethod(readonly=True)
    // def get_label(self, id: String) -> LabelDescriptor:  # noqa A002
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:118
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz get_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:118
    // ensure(id in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

get_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:119
    // return self.labels[id]
    frame_dig -1
    box_get
    assert // check self.labels entry exists
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.log_labels(ids: bytes) -> void:
log_labels:
    // smart_contracts/asset_labeling/contract.py:121-122
    // @abimethod(readonly=True)
    // def log_labels(self, ids: arc4.DynamicArray[arc4.String]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:123
    // for _idx, label_id in uenumerate(ids):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

log_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:123
    // for _idx, label_id in uenumerate(ids):
    frame_dig 1
    frame_dig 0
    <
    bz log_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    // smart_contracts/asset_labeling/contract.py:124
    // log(self.labels[label_id.native])
    extract 2 0
    box_get
    assert // check self.labels entry exists
    log
    intc_0 // 1
    +
    frame_bury 1
    b log_labels_for_header@1

log_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.admin_or_operator_only(label: bytes) -> void:
admin_or_operator_only:
    // smart_contracts/asset_labeling/contract.py:130-131
    // @subroutine
    // def admin_or_operator_only(self, label: String) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:132
    // if Txn.sender == self.admin:
    txn Sender
    intc_1 // 0
    bytec 5 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    bz admin_or_operator_only_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:133
    // return
    retsub

admin_or_operator_only_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:134
    // self.operator_only(label)
    frame_dig -1
    callsub operator_only
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.operator_only(label: bytes) -> void:
operator_only:
    // smart_contracts/asset_labeling/contract.py:136-137
    // @subroutine
    // def operator_only(self, label: String) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:138
    // operator_index = self.get_operator_label_index(Txn.sender, label)
    txn Sender
    frame_dig -1
    callsub get_operator_label_index
    dup
    // smart_contracts/asset_labeling/contract.py:140
    // operator_index != UInt64(NOT_FOUND_KEY)
    intc 5 // 4294967296
    !=
    // smart_contracts/asset_labeling/contract.py:140-141
    // operator_index != UInt64(NOT_FOUND_KEY)
    // and operator_index != UInt64(NOT_FOUND_VALUE),
    bz operator_only_bool_false@3
    // smart_contracts/asset_labeling/contract.py:141
    // and operator_index != UInt64(NOT_FOUND_VALUE),
    frame_dig 0
    intc 4 // 4294967295
    !=
    // smart_contracts/asset_labeling/contract.py:140-141
    // operator_index != UInt64(NOT_FOUND_KEY)
    // and operator_index != UInt64(NOT_FOUND_VALUE),
    bz operator_only_bool_false@3
    intc_0 // 1

operator_only_bool_merge@4:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz operator_only_after_if_else@7
    // smart_contracts/asset_labeling/contract.py:142
    // S("ERR:UNAUTH"),
    bytec 11 // "ERR:UNAUTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

operator_only_after_if_else@7:
    retsub

operator_only_bool_false@3:
    intc_1 // 0
    b operator_only_bool_merge@4


// smart_contracts.asset_labeling.contract.AssetLabeling.get_operator_label_index(operator: bytes, label: bytes) -> uint64:
get_operator_label_index:
    // smart_contracts/asset_labeling/contract.py:145-146
    // @subroutine
    // def get_operator_label_index(self, operator: Account, label: String) -> UInt64:
    proto 2 1
    intc_1 // 0
    bytec_3 // ""
    dup
    // smart_contracts/asset_labeling/contract.py:147
    // if operator not in self.operators:
    frame_dig -2
    box_len
    bury 1
    bnz get_operator_label_index_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:148
    // return UInt64(NOT_FOUND_KEY)
    intc 5 // 4294967296
    frame_bury 0
    retsub

get_operator_label_index_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:149
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig -2
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.operators entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 1
    intc_1 // 0
    frame_bury 2

get_operator_label_index_for_header@3:
    // smart_contracts/asset_labeling/contract.py:149
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig 2
    frame_dig 1
    <
    bz get_operator_label_index_after_for@8
    frame_dig 0
    extract 2 0
    frame_dig 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    // smart_contracts/asset_labeling/contract.py:150
    // if stored_label == label:
    extract 2 0
    frame_dig -1
    ==
    bz get_operator_label_index_after_if_else@6
    // smart_contracts/asset_labeling/contract.py:151
    // return idx
    frame_dig 2
    frame_bury 0
    retsub

get_operator_label_index_after_if_else@6:
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b get_operator_label_index_for_header@3

get_operator_label_index_after_for@8:
    // smart_contracts/asset_labeling/contract.py:152
    // return UInt64(NOT_FOUND_VALUE)
    intc 4 // 4294967295
    frame_bury 0
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.add_operator_to_label(operator: bytes, label: bytes) -> void:
add_operator_to_label:
    // smart_contracts/asset_labeling/contract.py:154-155
    // @abimethod()
    // def add_operator_to_label(self, operator: Account, label: String) -> None:
    proto 2 0
    // smart_contracts/asset_labeling/contract.py:156
    // self.admin_or_operator_only(label)
    frame_dig -1
    callsub admin_or_operator_only
    // smart_contracts/asset_labeling/contract.py:157
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz add_operator_to_label_after_if_else@10
    // smart_contracts/asset_labeling/contract.py:157
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_operator_to_label_after_if_else@10:
    // smart_contracts/asset_labeling/contract.py:158-159
    // # check if operator exists already
    // if operator in self.operators:
    frame_dig -2
    box_len
    bury 1
    bz add_operator_to_label_else_body@2
    // smart_contracts/asset_labeling/contract.py:162
    // self.get_operator_label_index(operator, label)
    frame_dig -2
    frame_dig -1
    callsub get_operator_label_index
    // smart_contracts/asset_labeling/contract.py:163
    // == UInt64(NOT_FOUND_VALUE),
    intc 4 // 4294967295
    // smart_contracts/asset_labeling/contract.py:162-163
    // self.get_operator_label_index(operator, label)
    // == UInt64(NOT_FOUND_VALUE),
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz add_operator_to_label_after_if_else@6
    // smart_contracts/asset_labeling/contract.py:164
    // S("ERR:EXISTS"),
    bytec 7 // "ERR:EXISTS"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

add_operator_to_label_after_if_else@6:
    // smart_contracts/asset_labeling/contract.py:167-168
    // # add label to operator
    // existing = self.operators[operator].copy()
    frame_dig -2
    box_get
    assert // check self.operators entry exists
    // smart_contracts/asset_labeling/contract.py:169
    // existing.append(arc4.String(label))
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    // smart_contracts/asset_labeling/contract.py:170
    // self.operators[operator] = existing.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put

add_operator_to_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:175-176
    // # increment label operators
    // label_descriptor = self.labels[label].copy()
    frame_dig -1
    box_get
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:178
    // label_descriptor.num_operators.native + UInt64(1)
    dup
    pushint 12 // 12
    extract_uint64
    intc_0 // 1
    +
    // smart_contracts/asset_labeling/contract.py:177-179
    // label_descriptor.num_operators = arc4.UInt64(
    //     label_descriptor.num_operators.native + UInt64(1)
    // )
    itob
    replace2 12
    // smart_contracts/asset_labeling/contract.py:180
    // self.labels[label] = label_descriptor.copy()
    frame_dig -1
    box_del
    pop
    frame_dig -1
    swap
    box_put
    retsub

add_operator_to_label_else_body@2:
    // smart_contracts/asset_labeling/contract.py:172-173
    // # new operator, create new box
    // self.operators[operator] = arc4.DynamicArray(arc4.String(label))
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    bytec 9 // 0x0002
    swap
    concat
    bytec 12 // 0x0001
    swap
    concat
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    b add_operator_to_label_after_if_else@3


// smart_contracts.asset_labeling.contract.AssetLabeling.has_operator_label(operator: bytes, label: bytes) -> uint64:
has_operator_label:
    // smart_contracts/asset_labeling/contract.py:182-183
    // @abimethod(readonly=True)
    // def has_operator_label(self, operator: Account, label: String) -> UInt64:
    proto 2 1
    bytec_3 // ""
    // smart_contracts/asset_labeling/contract.py:184
    // ensure(label.bytes.length == 2, S("ERR:LENGTH"))
    frame_dig -1
    len
    intc_2 // 2
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz has_operator_label_after_if_else@7
    // smart_contracts/asset_labeling/contract.py:184
    // ensure(label.bytes.length == 2, S("ERR:LENGTH"))
    bytec 6 // "ERR:LENGTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

has_operator_label_after_if_else@7:
    // smart_contracts/asset_labeling/contract.py:185
    // idx = self.get_operator_label_index(operator, label)
    frame_dig -2
    frame_dig -1
    callsub get_operator_label_index
    dup
    frame_bury 0
    // smart_contracts/asset_labeling/contract.py:186
    // return UInt64(idx != NOT_FOUND_KEY and idx != NOT_FOUND_VALUE)
    intc 5 // 4294967296
    !=
    bz has_operator_label_bool_false@3
    frame_dig 0
    intc 4 // 4294967295
    !=
    bz has_operator_label_bool_false@3
    intc_0 // 1

has_operator_label_bool_merge@4:
    // smart_contracts/asset_labeling/contract.py:186
    // return UInt64(idx != NOT_FOUND_KEY and idx != NOT_FOUND_VALUE)
    swap
    retsub

has_operator_label_bool_false@3:
    intc_1 // 0
    b has_operator_label_bool_merge@4


// smart_contracts.asset_labeling.contract.AssetLabeling.remove_operator_from_label(operator: bytes, label: bytes) -> void:
remove_operator_from_label:
    // smart_contracts/asset_labeling/contract.py:188-189
    // @abimethod()
    // def remove_operator_from_label(self, operator: Account, label: String) -> None:
    proto 2 0
    intc_1 // 0
    dupn 4
    bytec_3 // ""
    dupn 2
    // smart_contracts/asset_labeling/contract.py:190
    // self.admin_or_operator_only(label)
    frame_dig -1
    callsub admin_or_operator_only
    // smart_contracts/asset_labeling/contract.py:192
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -1
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@28
    // smart_contracts/asset_labeling/contract.py:192
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@28:
    // smart_contracts/asset_labeling/contract.py:193
    // ensure(operator in self.operators, S("ERR:NOEXIST"))
    frame_dig -2
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@32
    // smart_contracts/asset_labeling/contract.py:193
    // ensure(operator in self.operators, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@32:
    // smart_contracts/asset_labeling/contract.py:195-196
    // # ensure label exists in operator
    // label_idx = self.get_operator_label_index(operator, label)
    frame_dig -2
    frame_dig -1
    callsub get_operator_label_index
    dup
    frame_bury 7
    // smart_contracts/asset_labeling/contract.py:198
    // label_idx != UInt64(NOT_FOUND_VALUE)
    intc 4 // 4294967295
    !=
    // smart_contracts/asset_labeling/contract.py:198-200
    // label_idx != UInt64(NOT_FOUND_VALUE)
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    bz remove_operator_from_label_bool_false@3
    // smart_contracts/asset_labeling/contract.py:199-200
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    frame_dig 7
    // smart_contracts/asset_labeling/contract.py:200
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    intc 5 // 4294967296
    // smart_contracts/asset_labeling/contract.py:199-200
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    !=
    // smart_contracts/asset_labeling/contract.py:198-200
    // label_idx != UInt64(NOT_FOUND_VALUE)
    // and label_idx
    // != UInt64(NOT_FOUND_KEY),  # key check redundant, checked above
    bz remove_operator_from_label_bool_false@3
    intc_0 // 1

remove_operator_from_label_bool_merge@4:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@24
    // smart_contracts/asset_labeling/contract.py:201
    // S("ERR:NOEXIST"),
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@24:
    // smart_contracts/asset_labeling/contract.py:204-205
    // # ensure only empty labels can be left operator-less
    // label_descriptor = self.labels[label].copy()
    frame_dig -1
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:207
    // label_descriptor.num_operators > 1 or label_descriptor.num_assets == 0,
    extract 12 8 // on error: Index access is out of bounds
    pushbytes 0x0000000000000001
    b>
    bnz remove_operator_from_label_bool_true@6
    frame_dig 0
    extract 4 8 // on error: Index access is out of bounds
    bytec 4 // 0x0000000000000000
    b==
    bz remove_operator_from_label_bool_false@7

remove_operator_from_label_bool_true@6:
    intc_0 // 1

remove_operator_from_label_bool_merge@8:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_operator_from_label_after_if_else@20
    // smart_contracts/asset_labeling/contract.py:208
    // S("ERR:NOEMPTY"),
    bytec 8 // "ERR:NOEMPTY"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_operator_from_label_after_if_else@20:
    // smart_contracts/asset_labeling/contract.py:212
    // label_descriptor.num_operators.native - UInt64(1)
    frame_dig 0
    dup
    pushint 12 // 12
    extract_uint64
    intc_0 // 1
    -
    // smart_contracts/asset_labeling/contract.py:210-213
    // # decr operator count
    // label_descriptor.num_operators = arc4.UInt64(
    //     label_descriptor.num_operators.native - UInt64(1)
    // )
    itob
    replace2 12
    // smart_contracts/asset_labeling/contract.py:214
    // self.labels[label] = label_descriptor.copy()
    frame_dig -1
    box_del
    pop
    frame_dig -1
    swap
    box_put
    // smart_contracts/asset_labeling/contract.py:216
    // if self.operators[operator].length == 1:
    frame_dig -2
    box_get
    assert // check self.operators entry exists
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    ==
    bz remove_operator_from_label_else_body@10
    // smart_contracts/asset_labeling/contract.py:217
    // del self.operators[operator]
    frame_dig -2
    box_del
    pop
    retsub

remove_operator_from_label_else_body@10:
    // smart_contracts/asset_labeling/contract.py:219
    // next_list = arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    frame_bury 2
    // smart_contracts/asset_labeling/contract.py:220-223
    // # walk, push everything except index
    // # this implementation walks twice (once in get_operator_label_index)
    // # could be more efficient
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig -2
    box_get
    swap
    dup
    cover 2
    frame_bury 1
    assert // check self.operators entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 5
    intc_1 // 0
    frame_bury 6

remove_operator_from_label_for_header@11:
    // smart_contracts/asset_labeling/contract.py:220-223
    // # walk, push everything except index
    // # this implementation walks twice (once in get_operator_label_index)
    // # could be more efficient
    // for idx, stored_label in uenumerate(self.operators[operator]):
    frame_dig 6
    frame_dig 5
    <
    bz remove_operator_from_label_after_for@16
    frame_dig 1
    extract 2 0
    frame_dig 6
    dup
    cover 2
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    frame_bury 4
    // smart_contracts/asset_labeling/contract.py:224
    // if label_idx != idx:
    frame_dig 7
    !=
    frame_dig 2
    frame_bury 3
    bz remove_operator_from_label_after_if_else@14
    // smart_contracts/asset_labeling/contract.py:225
    // next_list.append(stored_label)
    frame_dig 2
    frame_dig 4
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    frame_bury 3

remove_operator_from_label_after_if_else@14:
    frame_dig 3
    frame_bury 2
    frame_dig 6
    intc_0 // 1
    +
    frame_bury 6
    b remove_operator_from_label_for_header@11

remove_operator_from_label_after_for@16:
    // smart_contracts/asset_labeling/contract.py:227
    // self.operators[operator] = next_list.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    frame_dig 2
    box_put
    retsub

remove_operator_from_label_bool_false@7:
    intc_1 // 0
    b remove_operator_from_label_bool_merge@8

remove_operator_from_label_bool_false@3:
    intc_1 // 0
    b remove_operator_from_label_bool_merge@4


// smart_contracts.asset_labeling.contract.AssetLabeling.get_operator_labels(operator: bytes) -> bytes:
get_operator_labels:
    // smart_contracts/asset_labeling/contract.py:229-230
    // @abimethod(readonly=True)
    // def get_operator_labels(self, operator: Account) -> LabelList:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:231
    // if operator in self.operators:
    frame_dig -1
    box_len
    bury 1
    bz get_operator_labels_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:232
    // return self.operators[operator]
    frame_dig -1
    box_get
    assert // check self.operators entry exists
    retsub

get_operator_labels_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    // smart_contracts/asset_labeling/contract.py:233-234
    // # return empty list
    // return empty_list()
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_label_index(asset: uint64, label: bytes) -> uint64:
get_asset_label_index:
    // smart_contracts/asset_labeling/contract.py:236-237
    // @subroutine
    // def get_asset_label_index(self, asset: Asset, label: String) -> UInt64:
    proto 2 1
    intc_1 // 0
    dup
    bytec_3 // ""
    dup
    // smart_contracts/asset_labeling/contract.py:238
    // ensure(label.bytes.length == 2, S("ERR:LENGTH"))
    frame_dig -1
    len
    intc_2 // 2
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz get_asset_label_index_after_if_else@11
    // smart_contracts/asset_labeling/contract.py:238
    // ensure(label.bytes.length == 2, S("ERR:LENGTH"))
    bytec 6 // "ERR:LENGTH"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

get_asset_label_index_after_if_else@11:
    // smart_contracts/asset_labeling/contract.py:239
    // if asset not in self.assets:
    frame_dig -2
    itob
    dup
    frame_bury 1
    box_len
    bury 1
    bnz get_asset_label_index_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:240
    // return UInt64(NOT_FOUND_KEY)
    intc 5 // 4294967296
    frame_bury 0
    retsub

get_asset_label_index_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:241
    // for idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 1
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.assets entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 2
    intc_1 // 0
    frame_bury 3

get_asset_label_index_for_header@3:
    // smart_contracts/asset_labeling/contract.py:241
    // for idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 3
    frame_dig 2
    <
    bz get_asset_label_index_after_for@8
    frame_dig 0
    extract 2 0
    frame_dig 3
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    // smart_contracts/asset_labeling/contract.py:242
    // if stored_label == label:
    extract 2 0
    frame_dig -1
    ==
    bz get_asset_label_index_after_if_else@6
    // smart_contracts/asset_labeling/contract.py:243
    // return idx
    frame_dig 3
    frame_bury 0
    retsub

get_asset_label_index_after_if_else@6:
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    b get_asset_label_index_for_header@3

get_asset_label_index_after_for@8:
    // smart_contracts/asset_labeling/contract.py:244
    // return UInt64(NOT_FOUND_VALUE)
    intc 4 // 4294967295
    frame_bury 0
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._add_label_to_asset(label: bytes, asset: uint64) -> void:
_add_label_to_asset:
    // smart_contracts/asset_labeling/contract.py:246-247
    // @subroutine
    // def _add_label_to_asset(self, label: String, asset: Asset) -> None:
    proto 2 0
    intc_1 // 0
    // smart_contracts/asset_labeling/contract.py:248
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -2
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz _add_label_to_asset_after_if_else@10
    // smart_contracts/asset_labeling/contract.py:248
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

_add_label_to_asset_after_if_else@10:
    // smart_contracts/asset_labeling/contract.py:249
    // if asset in self.assets:
    frame_dig -1
    itob
    dup
    frame_bury 0
    box_len
    bury 1
    bz _add_label_to_asset_else_body@2
    // smart_contracts/asset_labeling/contract.py:252
    // self.get_asset_label_index(asset, label) == UInt64(NOT_FOUND_VALUE),
    frame_dig -1
    frame_dig -2
    callsub get_asset_label_index
    intc 4 // 4294967295
    ==
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz _add_label_to_asset_after_if_else@6
    // smart_contracts/asset_labeling/contract.py:253
    // S("ERR:EXISTS"),
    bytec 7 // "ERR:EXISTS"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

_add_label_to_asset_after_if_else@6:
    // smart_contracts/asset_labeling/contract.py:255-256
    // # add label to asset
    // existing = self.assets[asset].copy()
    frame_dig 0
    dup
    box_get
    assert // check self.assets entry exists
    // smart_contracts/asset_labeling/contract.py:257
    // existing.append(arc4.String(label))
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    // smart_contracts/asset_labeling/contract.py:258
    // self.assets[asset] = existing.copy()
    dig 1
    box_del
    pop
    box_put

_add_label_to_asset_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:263-264
    // # incr asset count
    // label_descriptor = self.labels[label].copy()
    frame_dig -2
    box_get
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:266
    // label_descriptor.num_assets.native + UInt64(1)
    dup
    pushint 4 // 4
    extract_uint64
    intc_0 // 1
    +
    // smart_contracts/asset_labeling/contract.py:265-267
    // label_descriptor.num_assets = arc4.UInt64(
    //     label_descriptor.num_assets.native + UInt64(1)
    // )
    itob
    replace2 4
    // smart_contracts/asset_labeling/contract.py:268
    // self.labels[label] = label_descriptor.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    retsub

_add_label_to_asset_else_body@2:
    // smart_contracts/asset_labeling/contract.py:260-261
    // # new asset, create new box
    // self.assets[asset] = arc4.DynamicArray(arc4.String(label))
    frame_dig -2
    len
    itob
    extract 6 2
    frame_dig -2
    concat
    bytec 9 // 0x0002
    swap
    concat
    bytec 12 // 0x0001
    swap
    concat
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    b _add_label_to_asset_after_if_else@3


// smart_contracts.asset_labeling.contract.AssetLabeling.add_label_to_asset(label: bytes, asset: uint64) -> void:
add_label_to_asset:
    // smart_contracts/asset_labeling/contract.py:270-271
    // @abimethod()
    // def add_label_to_asset(self, label: String, asset: Asset) -> None:
    proto 2 0
    // smart_contracts/asset_labeling/contract.py:272
    // self.operator_only(label)
    frame_dig -2
    callsub operator_only
    // smart_contracts/asset_labeling/contract.py:273
    // self._add_label_to_asset(label, asset)
    frame_dig -2
    frame_dig -1
    callsub _add_label_to_asset
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.add_label_to_assets(label: bytes, assets: bytes) -> void:
add_label_to_assets:
    // smart_contracts/asset_labeling/contract.py:275-278
    // @abimethod()
    // def add_label_to_assets(
    //     self, label: String, assets: arc4.DynamicArray[arc4.UInt64]
    // ) -> None:
    proto 2 0
    // smart_contracts/asset_labeling/contract.py:279
    // self.operator_only(label)
    frame_dig -2
    callsub operator_only
    // smart_contracts/asset_labeling/contract.py:280
    // for _i, asset in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

add_label_to_assets_for_header@1:
    // smart_contracts/asset_labeling/contract.py:280
    // for _i, asset in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz add_label_to_assets_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:281
    // self._add_label_to_asset(label, Asset(asset.native))
    extract_uint64
    frame_dig -2
    swap
    callsub _add_label_to_asset
    intc_0 // 1
    +
    frame_bury 1
    b add_label_to_assets_for_header@1

add_label_to_assets_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.remove_label_from_asset(label: bytes, asset: uint64) -> void:
remove_label_from_asset:
    // smart_contracts/asset_labeling/contract.py:283-284
    // @abimethod()
    // def remove_label_from_asset(self, label: String, asset: Asset) -> None:
    proto 2 0
    intc_1 // 0
    dupn 3
    bytec_3 // ""
    dupn 2
    // smart_contracts/asset_labeling/contract.py:285
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    frame_dig -2
    box_len
    bury 1
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    bnz remove_label_from_asset_after_if_else@20
    // smart_contracts/asset_labeling/contract.py:285
    // ensure(label in self.labels, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_from_asset_after_if_else@20:
    // smart_contracts/asset_labeling/contract.py:287
    // self.operator_only(label)
    frame_dig -2
    callsub operator_only
    // smart_contracts/asset_labeling/contract.py:289
    // found = False
    intc_1 // 0
    frame_bury 6
    // smart_contracts/asset_labeling/contract.py:290
    // if self.assets[asset].length == 1:
    frame_dig -1
    itob
    dup
    frame_bury 3
    box_get
    assert // check self.assets entry exists
    intc_1 // 0
    extract_uint16
    intc_0 // 1
    ==
    bz remove_label_from_asset_else_body@5
    // smart_contracts/asset_labeling/contract.py:291
    // if self.assets[asset][0] == label:
    frame_dig 3
    box_get
    assert // check self.assets entry exists
    dup
    extract 2 0
    swap
    intc_1 // 0
    extract_uint16
    assert // Index access is out of bounds
    dup
    intc_1 // 0
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    extract 2 0
    frame_dig -2
    ==
    bz remove_label_from_asset_else_body@3
    // smart_contracts/asset_labeling/contract.py:292
    // del self.assets[asset]
    frame_dig 3
    box_del
    pop
    // smart_contracts/asset_labeling/contract.py:293
    // found = True
    intc_0 // 1
    frame_bury 6

remove_label_from_asset_after_if_else@13:
    // smart_contracts/asset_labeling/contract.py:42
    // if not cond:
    frame_dig 6
    bnz remove_label_from_asset_after_if_else@16
    // smart_contracts/asset_labeling/contract.py:308
    // ensure(found, S("ERR:NOEXIST"))
    bytec_2 // "ERR:NOEXIST"
    // smart_contracts/asset_labeling/contract.py:43
    // log(msg)
    log
    // smart_contracts/asset_labeling/contract.py:44
    // op.err()
    err

remove_label_from_asset_after_if_else@16:
    // smart_contracts/asset_labeling/contract.py:310-311
    // # decr asset count
    // label_descriptor = self.labels[label].copy()
    frame_dig -2
    box_get
    assert // check self.labels entry exists
    // smart_contracts/asset_labeling/contract.py:313
    // label_descriptor.num_assets.native - UInt64(1)
    dup
    pushint 4 // 4
    extract_uint64
    intc_0 // 1
    -
    // smart_contracts/asset_labeling/contract.py:312-314
    // label_descriptor.num_assets = arc4.UInt64(
    //     label_descriptor.num_assets.native - UInt64(1)
    // )
    itob
    replace2 4
    // smart_contracts/asset_labeling/contract.py:315
    // self.labels[label] = label_descriptor.copy()
    frame_dig -2
    box_del
    pop
    frame_dig -2
    swap
    box_put
    retsub

remove_label_from_asset_else_body@3:
    // smart_contracts/asset_labeling/contract.py:295
    // found = False
    intc_1 // 0
    frame_bury 6
    b remove_label_from_asset_after_if_else@13

remove_label_from_asset_else_body@5:
    // smart_contracts/asset_labeling/contract.py:297
    // next_list = arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    frame_bury 1
    // smart_contracts/asset_labeling/contract.py:298-300
    // # walk, push everything to new box except label
    // # save $found to throw if not found
    // for _idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 3
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.assets entry exists
    intc_1 // 0
    extract_uint16
    frame_bury 5
    intc_1 // 0
    frame_bury 4

remove_label_from_asset_for_header@6:
    // smart_contracts/asset_labeling/contract.py:298-300
    // # walk, push everything to new box except label
    // # save $found to throw if not found
    // for _idx, stored_label in uenumerate(self.assets[asset]):
    frame_dig 4
    frame_dig 5
    <
    bz remove_label_from_asset_after_for@12
    frame_dig 0
    extract 2 0
    frame_dig 4
    intc_2 // 2
    *
    dig 1
    swap
    extract_uint16
    dup2
    extract_uint16
    intc_2 // 2
    +
    extract3
    dup
    frame_bury 2
    // smart_contracts/asset_labeling/contract.py:301
    // if stored_label != label:
    extract 2 0
    frame_dig -2
    !=
    bz remove_label_from_asset_else_body@9
    // smart_contracts/asset_labeling/contract.py:302
    // next_list.append(stored_label)
    frame_dig 1
    frame_dig 2
    intc_0 // 1
    callsub dynamic_array_concat_byte_length_head
    frame_bury 1

remove_label_from_asset_after_if_else@10:
    frame_dig 4
    intc_0 // 1
    +
    frame_bury 4
    b remove_label_from_asset_for_header@6

remove_label_from_asset_else_body@9:
    // smart_contracts/asset_labeling/contract.py:304
    // found = True
    intc_0 // 1
    frame_bury 6
    b remove_label_from_asset_after_if_else@10

remove_label_from_asset_after_for@12:
    // smart_contracts/asset_labeling/contract.py:306
    // self.assets[asset] = next_list.copy()
    frame_dig 3
    dup
    box_del
    pop
    frame_dig 1
    box_put
    b remove_label_from_asset_after_if_else@13


// smart_contracts.asset_labeling.contract.AssetLabeling.has_asset_label(asset_id: uint64, label: bytes) -> uint64:
has_asset_label:
    // smart_contracts/asset_labeling/contract.py:317-318
    // @abimethod(readonly=True)
    // def has_asset_label(self, asset_id: UInt64, label: String) -> UInt64:
    proto 2 1
    // smart_contracts/asset_labeling/contract.py:320
    // idx = self.get_asset_label_index(asset, label)
    frame_dig -2
    frame_dig -1
    callsub get_asset_label_index
    dup
    // smart_contracts/asset_labeling/contract.py:321
    // if idx != NOT_FOUND_KEY and idx != NOT_FOUND_VALUE:
    intc 5 // 4294967296
    !=
    bz has_asset_label_after_if_else@3
    frame_dig 0
    intc 4 // 4294967295
    !=
    bz has_asset_label_after_if_else@3
    // smart_contracts/asset_labeling/contract.py:322
    // return UInt64(1)
    intc_0 // 1
    swap
    retsub

has_asset_label_after_if_else@3:
    // smart_contracts/asset_labeling/contract.py:323
    // return UInt64(0)
    intc_1 // 0
    swap
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_labels(asset: uint64) -> bytes:
get_asset_labels:
    // smart_contracts/asset_labeling/contract.py:325-326
    // @abimethod(readonly=True)
    // def get_asset_labels(self, asset: Asset) -> LabelList:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:327
    // if asset in self.assets:
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz get_asset_labels_after_if_else@2
    // smart_contracts/asset_labeling/contract.py:328
    // return self.assets[asset]
    frame_dig 0
    box_get
    assert // check self.assets entry exists
    swap
    retsub

get_asset_labels_after_if_else@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    // smart_contracts/asset_labeling/contract.py:329-330
    // # return empty
    // return empty_list()
    swap
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_labels(assets: bytes) -> bytes:
get_assets_labels:
    // smart_contracts/asset_labeling/contract.py:332-335
    // @abimethod(readonly=True)
    // def get_assets_labels(
    //     self, assets: arc4.DynamicArray[arc4.UInt64]
    // ) -> arc4.DynamicArray[LabelList]:
    proto 1 1
    intc_1 // 0
    // smart_contracts/asset_labeling/contract.py:336
    // out = arc4.DynamicArray[LabelList]()
    bytec_1 // 0x0000
    // smart_contracts/asset_labeling/contract.py:337
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:337
    // for _i, asset_id in uenumerate(assets):
    frame_dig 3
    frame_dig 2
    <
    bz get_assets_labels_after_for@7
    frame_dig -1
    extract 2 0
    frame_dig 3
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:338
    // asset = Asset(asset_id.native)
    extract_uint64
    // smart_contracts/asset_labeling/contract.py:339
    // if asset in self.assets:
    itob
    dup
    frame_bury 0
    box_len
    bury 1
    bz get_assets_labels_else_body@4
    // smart_contracts/asset_labeling/contract.py:340
    // out.append(self.assets[asset].copy())
    frame_dig 0
    box_get
    assert // check self.assets entry exists
    bytec 9 // 0x0002
    swap
    concat
    frame_dig 1
    dup
    intc_1 // 0
    extract_uint16
    swap
    extract 2 0
    intc_0 // 1
    uncover 3
    callsub dynamic_array_concat_dynamic_element
    frame_bury 1

get_assets_labels_after_if_else@5:
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    b get_assets_labels_for_header@1

get_assets_labels_else_body@4:
    // smart_contracts/asset_labeling/contract.py:342
    // out.append(empty_list())
    frame_dig 1
    dup
    intc_1 // 0
    extract_uint16
    swap
    extract 2 0
    intc_0 // 1
    pushbytes 0x00020000
    callsub dynamic_array_concat_dynamic_element
    frame_bury 1
    b get_assets_labels_after_if_else@5

get_assets_labels_after_for@7:
    // smart_contracts/asset_labeling/contract.py:343
    // return out
    frame_dig 1
    frame_bury 0
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.log_assets_labels(assets: bytes) -> void:
log_assets_labels:
    // smart_contracts/asset_labeling/contract.py:345-346
    // @abimethod(readonly=True)
    // def log_assets_labels(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    intc_1 // 0
    // smart_contracts/asset_labeling/contract.py:347
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

log_assets_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:347
    // for _i, asset_id in uenumerate(assets):
    frame_dig 2
    frame_dig 1
    <
    bz log_assets_labels_after_for@7
    frame_dig -1
    extract 2 0
    frame_dig 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:348
    // asset = Asset(asset_id.native)
    extract_uint64
    // smart_contracts/asset_labeling/contract.py:349
    // if asset in self.assets:
    itob
    dup
    frame_bury 0
    box_len
    bury 1
    bz log_assets_labels_else_body@4
    // smart_contracts/asset_labeling/contract.py:350
    // log(self.assets[asset])
    frame_dig 0
    box_get
    assert // check self.assets entry exists
    log

log_assets_labels_after_if_else@5:
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b log_assets_labels_for_header@1

log_assets_labels_else_body@4:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    // smart_contracts/asset_labeling/contract.py:352
    // log(empty_list())
    log
    b log_assets_labels_after_if_else@5

log_assets_labels_after_for@7:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_micro(asset_id: uint64) -> bytes:
_get_asset_micro:
    // smart_contracts/asset_labeling/contract.py:360-361
    // @subroutine
    // def _get_asset_micro(self, asset_id: UInt64) -> AssetMicro:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:364
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:365
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:363-366
    // return AssetMicro(
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    // )
    pushbytes 0x0003
    swap
    concat
    swap
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_micro(asset: uint64) -> bytes:
get_asset_micro:
    // smart_contracts/asset_labeling/contract.py:368-369
    // @abimethod(readonly=True)
    // def get_asset_micro(self, asset: UInt64) -> AssetMicro:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:370
    // return self._get_asset_micro(asset)
    frame_dig -1
    callsub _get_asset_micro
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_micro(assets: bytes) -> void:
get_assets_micro:
    // smart_contracts/asset_labeling/contract.py:372-373
    // @abimethod(readonly=True)
    // def get_assets_micro(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:374
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_micro_for_header@1:
    // smart_contracts/asset_labeling/contract.py:374
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_micro_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:375
    // log(self._get_asset_micro(asset_id.native))
    extract_uint64
    callsub _get_asset_micro
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_micro_for_header@1

get_assets_micro_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_micro_labels(asset_id: uint64) -> bytes:
_get_asset_micro_labels:
    // smart_contracts/asset_labeling/contract.py:379-380
    // @subroutine
    // def _get_asset_micro_labels(self, asset_id: UInt64) -> AssetMicroLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:383
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:384
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:385
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_micro_labels_ternary_false@2
    frame_dig 2
    box_get
    assert // check self.assets entry exists

_get_asset_micro_labels_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:382-386
    // return AssetMicroLabels(
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    pushint 5 // 5
    +
    bytec 13 // 0x0005
    frame_dig 1
    concat
    swap
    itob
    extract 6 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_micro_labels_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_micro_labels_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_micro_labels(asset: uint64) -> bytes:
get_asset_micro_labels:
    // smart_contracts/asset_labeling/contract.py:388-389
    // @abimethod(readonly=True)
    // def get_asset_micro_labels(self, asset: UInt64) -> AssetMicroLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:390
    // return self._get_asset_micro_labels(asset)
    frame_dig -1
    callsub _get_asset_micro_labels
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_micro_labels(assets: bytes) -> void:
get_assets_micro_labels:
    // smart_contracts/asset_labeling/contract.py:392-393
    // @abimethod(readonly=True)
    // def get_assets_micro_labels(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:394
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_micro_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:394
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_micro_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:395
    // log(self._get_asset_micro_labels(asset_id.native))
    extract_uint64
    callsub _get_asset_micro_labels
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_micro_labels_for_header@1

get_assets_micro_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_tiny(asset_id: uint64) -> bytes:
_get_asset_tiny:
    // smart_contracts/asset_labeling/contract.py:399-400
    // @subroutine
    // def _get_asset_tiny(self, asset_id: UInt64) -> AssetTiny:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:403
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:404
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:405
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:402-406
    // return AssetTiny(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    // )
    dig 2
    len
    pushint 5 // 5
    +
    itob
    extract 6 2
    bytec 13 // 0x0005
    swap
    concat
    swap
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_tiny(asset: uint64) -> bytes:
get_asset_tiny:
    // smart_contracts/asset_labeling/contract.py:408-409
    // @abimethod(readonly=True)
    // def get_asset_tiny(self, asset: UInt64) -> AssetTiny:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:410
    // return self._get_asset_tiny(asset)
    frame_dig -1
    callsub _get_asset_tiny
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_tiny(assets: bytes) -> void:
get_assets_tiny:
    // smart_contracts/asset_labeling/contract.py:412-413
    // @abimethod(readonly=True)
    // def get_assets_tiny(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:414
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_tiny_for_header@1:
    // smart_contracts/asset_labeling/contract.py:414
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_tiny_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:415
    // log(self._get_asset_tiny(asset_id.native))
    extract_uint64
    callsub _get_asset_tiny
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_tiny_for_header@1

get_assets_tiny_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_tiny_labels(asset_id: uint64) -> bytes:
_get_asset_tiny_labels:
    // smart_contracts/asset_labeling/contract.py:419-420
    // @subroutine
    // def _get_asset_tiny_labels(self, asset_id: UInt64) -> AssetTinyLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:423
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:424
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:425
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:426
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_tiny_labels_ternary_false@2
    frame_dig 3
    box_get
    assert // check self.assets entry exists

_get_asset_tiny_labels_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:422-427
    // return AssetTinyLabels(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    pushint 7 // 7
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0007
    swap
    concat
    frame_dig 1
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 2
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_tiny_labels_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_tiny_labels_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_tiny_labels(asset: uint64) -> bytes:
get_asset_tiny_labels:
    // smart_contracts/asset_labeling/contract.py:429-430
    // @abimethod(readonly=True)
    // def get_asset_tiny_labels(self, asset: UInt64) -> AssetTinyLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:431
    // return self._get_asset_tiny_labels(asset)
    frame_dig -1
    callsub _get_asset_tiny_labels
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_tiny_labels(assets: bytes) -> void:
get_assets_tiny_labels:
    // smart_contracts/asset_labeling/contract.py:433-434
    // @abimethod(readonly=True)
    // def get_assets_tiny_labels(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:435
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_tiny_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:435
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_tiny_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:436
    // log(self._get_asset_tiny_labels(asset_id.native))
    extract_uint64
    callsub _get_asset_tiny_labels
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_tiny_labels_for_header@1

get_assets_tiny_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_text(asset_id: uint64) -> bytes:
_get_asset_text:
    // smart_contracts/asset_labeling/contract.py:440-441
    // @subroutine
    // def _get_asset_text(self, asset_id: UInt64) -> AssetText:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:444
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:445
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:446
    // url=b2str(asset.url),
    frame_dig -1
    asset_params_get AssetURL
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:443-447
    // return AssetText(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     url=b2str(asset.url),
    // )
    dig 2
    len
    pushint 6 // 6
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0006
    swap
    concat
    dig 3
    len
    uncover 2
    +
    itob
    extract 6 2
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_text(asset: uint64) -> bytes:
get_asset_text:
    // smart_contracts/asset_labeling/contract.py:449-450
    // @abimethod(readonly=True)
    // def get_asset_text(self, asset: UInt64) -> AssetText:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:451
    // return self._get_asset_text(asset)
    frame_dig -1
    callsub _get_asset_text
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_text(assets: bytes) -> void:
get_assets_text:
    // smart_contracts/asset_labeling/contract.py:453-454
    // @abimethod(readonly=True)
    // def get_assets_text(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:455
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_text_for_header@1:
    // smart_contracts/asset_labeling/contract.py:455
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_text_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:456
    // log(self._get_asset_text(asset_id.native))
    extract_uint64
    callsub _get_asset_text
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_text_for_header@1

get_assets_text_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_text_labels(asset_id: uint64) -> bytes:
_get_asset_text_labels:
    // smart_contracts/asset_labeling/contract.py:460-461
    // @subroutine
    // def _get_asset_text_labels(self, asset_id: UInt64) -> AssetTextLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:464
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:465
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:466
    // url=b2str(asset.url),
    frame_dig -1
    asset_params_get AssetURL
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:467
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_text_labels_ternary_false@2
    frame_dig 3
    box_get
    assert // check self.assets entry exists

_get_asset_text_labels_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:463-468
    // return AssetTextLabels(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     url=b2str(asset.url),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    intc_3 // 8
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0008
    swap
    concat
    frame_dig 1
    dup
    cover 3
    len
    uncover 2
    +
    dup
    itob
    extract 6 2
    uncover 2
    swap
    concat
    frame_dig 2
    dup
    cover 3
    len
    uncover 2
    +
    itob
    extract 6 2
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_text_labels_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_text_labels_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_text_labels(asset: uint64) -> bytes:
get_asset_text_labels:
    // smart_contracts/asset_labeling/contract.py:470-471
    // @abimethod(readonly=True)
    // def get_asset_text_labels(self, asset: UInt64) -> AssetTextLabels:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:472
    // return self._get_asset_text_labels(asset)
    frame_dig -1
    callsub _get_asset_text_labels
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_text_labels(assets: bytes) -> void:
get_assets_text_labels:
    // smart_contracts/asset_labeling/contract.py:474-475
    // @abimethod(readonly=True)
    // def get_assets_text_labels(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:476
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_text_labels_for_header@1:
    // smart_contracts/asset_labeling/contract.py:476
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_text_labels_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:477
    // log(self._get_asset_text_labels(asset_id.native))
    extract_uint64
    callsub _get_asset_text_labels
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_text_labels_for_header@1

get_assets_text_labels_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_small(asset_id: uint64) -> bytes:
_get_asset_small:
    // smart_contracts/asset_labeling/contract.py:481-482
    // @subroutine
    // def _get_asset_small(self, asset_id: UInt64) -> AssetSmall:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:485
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:486
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    // smart_contracts/asset_labeling/contract.py:487
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/asset_labeling/contract.py:488
    // total=arc4.UInt64(asset.total),
    frame_dig -1
    asset_params_get AssetTotal
    assert // asset exists
    itob
    // smart_contracts/asset_labeling/contract.py:489
    // has_freeze=arc4.Bool(asset.freeze != Global.zero_address),
    frame_dig -1
    asset_params_get AssetFreeze
    assert // asset exists
    global ZeroAddress
    !=
    bytec 10 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/asset_labeling/contract.py:490
    // has_clawback=arc4.Bool(asset.clawback != Global.zero_address),
    frame_dig -1
    asset_params_get AssetClawback
    assert // asset exists
    global ZeroAddress
    !=
    bytec 10 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    // smart_contracts/asset_labeling/contract.py:491
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    box_len
    bury 1
    bz _get_asset_small_ternary_false@2
    frame_dig 6
    box_get
    assert // check self.assets entry exists

_get_asset_small_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:484-492
    // return AssetSmall(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     decimals=arc4.UInt8(asset.decimals),
    //     total=arc4.UInt64(asset.total),
    //     has_freeze=arc4.Bool(asset.freeze != Global.zero_address),
    //     has_clawback=arc4.Bool(asset.clawback != Global.zero_address),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 0
    dup
    len
    pushint 16 // 16
    +
    dup
    itob
    extract 6 2
    pushbytes 0x0010
    swap
    concat
    frame_dig 1
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 2
    concat
    frame_dig 3
    concat
    frame_dig 4
    concat
    frame_dig 5
    intc_1 // 0
    getbit
    pushint 105 // 105
    swap
    setbit
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_small_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_small_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_small(asset: uint64) -> bytes:
get_asset_small:
    // smart_contracts/asset_labeling/contract.py:494-495
    // @abimethod(readonly=True)
    // def get_asset_small(self, asset: UInt64) -> AssetSmall:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:496
    // return self._get_asset_small(asset)
    frame_dig -1
    callsub _get_asset_small
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_small(assets: bytes) -> void:
get_assets_small:
    // smart_contracts/asset_labeling/contract.py:498-499
    // @abimethod(readonly=True)
    // def get_assets_small(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:500
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_small_for_header@1:
    // smart_contracts/asset_labeling/contract.py:500
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_small_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:501
    // log(self._get_asset_small(asset_id.native))
    extract_uint64
    callsub _get_asset_small
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_small_for_header@1

get_assets_small_after_for@4:
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling._get_asset_full(asset_id: uint64) -> bytes:
_get_asset_full:
    // smart_contracts/asset_labeling/contract.py:505-506
    // @subroutine
    // def _get_asset_full(self, asset_id: UInt64) -> AssetFull:
    proto 1 1
    intc_1 // 0
    dupn 13
    // smart_contracts/asset_labeling/contract.py:508
    // reserve_acct = Account(asset.reserve.bytes)
    frame_dig -1
    asset_params_get AssetReserve
    swap
    dup
    uncover 2
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:511
    // if reserve_acct.is_opted_in(asset)
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/asset_labeling/contract.py:510-512
    // asset.balance(reserve_acct)
    // if reserve_acct.is_opted_in(asset)
    // else UInt64(0)
    bz _get_asset_full_ternary_false@2
    // smart_contracts/asset_labeling/contract.py:510
    // asset.balance(reserve_acct)
    frame_dig 14
    frame_dig -1
    asset_holding_get AssetBalance
    assert // account opted into asset

_get_asset_full_ternary_merge@3:
    // smart_contracts/asset_labeling/contract.py:515
    // name=b2str(asset.name),
    frame_dig -1
    asset_params_get AssetName
    assert // asset exists
    callsub b2str
    frame_bury 2
    // smart_contracts/asset_labeling/contract.py:516
    // unit_name=b2str(asset.unit_name),
    frame_dig -1
    asset_params_get AssetUnitName
    assert // asset exists
    callsub b2str
    frame_bury 3
    // smart_contracts/asset_labeling/contract.py:517
    // url=b2str(asset.url),
    frame_dig -1
    asset_params_get AssetURL
    assert // asset exists
    callsub b2str
    frame_bury 4
    // smart_contracts/asset_labeling/contract.py:518
    // total=arc4.UInt64(asset.total),
    frame_dig -1
    asset_params_get AssetTotal
    assert // asset exists
    itob
    frame_bury 7
    // smart_contracts/asset_labeling/contract.py:519
    // decimals=arc4.UInt8(asset.decimals),
    frame_dig -1
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    frame_bury 6
    // smart_contracts/asset_labeling/contract.py:520
    // creator=arc4.Address(asset.creator),
    frame_dig -1
    asset_params_get AssetCreator
    swap
    frame_bury 11
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:521
    // manager=arc4.Address(asset.manager),
    frame_dig -1
    asset_params_get AssetManager
    swap
    frame_bury 12
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:522
    // freeze=arc4.Address(asset.freeze),
    frame_dig -1
    asset_params_get AssetFreeze
    swap
    frame_bury 13
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:523
    // clawback=arc4.Address(asset.clawback),
    frame_dig -1
    asset_params_get AssetClawback
    swap
    frame_bury 9
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:524
    // reserve=arc4.Address(asset.reserve),
    frame_dig -1
    asset_params_get AssetReserve
    swap
    frame_bury 10
    assert // asset exists
    // smart_contracts/asset_labeling/contract.py:525
    // default_frozen=arc4.Bool(asset.default_frozen),
    frame_dig -1
    asset_params_get AssetDefaultFrozen
    assert // asset exists
    bytec 10 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    frame_bury 0
    // smart_contracts/asset_labeling/contract.py:527
    // metadata_hash=arc4.DynamicBytes(asset.metadata_hash),
    frame_dig -1
    asset_params_get AssetMetadataHash
    assert // asset exists
    dup
    len
    itob
    extract 6 2
    swap
    concat
    frame_bury 1
    // smart_contracts/asset_labeling/contract.py:526
    // reserve_balance=arc4.UInt64(reserve_balance),
    itob
    frame_bury 8
    // smart_contracts/asset_labeling/contract.py:528
    // labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    frame_dig -1
    itob
    dup
    frame_bury 5
    box_len
    bury 1
    bz _get_asset_full_ternary_false@5
    frame_dig 5
    box_get
    assert // check self.assets entry exists

_get_asset_full_ternary_merge@6:
    // smart_contracts/asset_labeling/contract.py:514-529
    // return AssetFull(
    //     name=b2str(asset.name),
    //     unit_name=b2str(asset.unit_name),
    //     url=b2str(asset.url),
    //     total=arc4.UInt64(asset.total),
    //     decimals=arc4.UInt8(asset.decimals),
    //     creator=arc4.Address(asset.creator),
    //     manager=arc4.Address(asset.manager),
    //     freeze=arc4.Address(asset.freeze),
    //     clawback=arc4.Address(asset.clawback),
    //     reserve=arc4.Address(asset.reserve),
    //     default_frozen=arc4.Bool(asset.default_frozen),
    //     reserve_balance=arc4.UInt64(reserve_balance),
    //     metadata_hash=arc4.DynamicBytes(asset.metadata_hash),
    //     labels=self.assets[asset].copy() if asset in self.assets else empty_list(),
    // )
    frame_dig 2
    dup
    len
    pushint 188 // 188
    +
    dup
    itob
    extract 6 2
    pushbytes 0x00bc
    swap
    concat
    frame_dig 3
    dup
    cover 3
    len
    uncover 2
    +
    dup
    itob
    extract 6 2
    uncover 2
    swap
    concat
    frame_dig 4
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 7
    concat
    frame_dig 6
    concat
    frame_dig 11
    concat
    frame_dig 12
    concat
    frame_dig 13
    concat
    frame_dig 9
    concat
    frame_dig 10
    concat
    frame_dig 0
    concat
    dig 1
    itob
    extract 6 2
    concat
    frame_dig 1
    dup
    cover 3
    len
    uncover 2
    +
    swap
    frame_dig 8
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    frame_bury 0
    retsub

_get_asset_full_ternary_false@5:
    // smart_contracts/asset_labeling/contract.py:49
    // return arc4.DynamicArray[arc4.String]()
    bytec_1 // 0x0000
    b _get_asset_full_ternary_merge@6

_get_asset_full_ternary_false@2:
    // smart_contracts/asset_labeling/contract.py:512
    // else UInt64(0)
    intc_1 // 0
    b _get_asset_full_ternary_merge@3


// smart_contracts.asset_labeling.contract.AssetLabeling.get_asset_full(asset: uint64) -> bytes:
get_asset_full:
    // smart_contracts/asset_labeling/contract.py:531-532
    // @abimethod(readonly=True)
    // def get_asset_full(self, asset: UInt64) -> AssetFull:
    proto 1 1
    // smart_contracts/asset_labeling/contract.py:533
    // return self._get_asset_full(asset)
    frame_dig -1
    callsub _get_asset_full
    retsub


// smart_contracts.asset_labeling.contract.AssetLabeling.get_assets_full(assets: bytes) -> void:
get_assets_full:
    // smart_contracts/asset_labeling/contract.py:535-536
    // @abimethod(readonly=True)
    // def get_assets_full(self, assets: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    // smart_contracts/asset_labeling/contract.py:537
    // for _i, asset_id in uenumerate(assets):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

get_assets_full_for_header@1:
    // smart_contracts/asset_labeling/contract.py:537
    // for _i, asset_id in uenumerate(assets):
    frame_dig 1
    frame_dig 0
    <
    bz get_assets_full_after_for@4
    frame_dig -1
    extract 2 0
    frame_dig 1
    dup
    cover 2
    intc_3 // 8
    *
    // smart_contracts/asset_labeling/contract.py:538
    // log(self._get_asset_full(asset_id.native))
    extract_uint64
    callsub _get_asset_full
    log
    intc_0 // 1
    +
    frame_bury 1
    b get_assets_full_for_header@1

get_assets_full_after_for@4:
    retsub
